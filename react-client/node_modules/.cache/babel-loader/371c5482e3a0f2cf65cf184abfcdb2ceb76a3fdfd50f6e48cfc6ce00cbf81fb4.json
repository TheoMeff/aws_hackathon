{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef } from 'react';\nimport { useEffect, useMemo } from 'react';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { getAllFocusables } from '../../internal/components/focus-lock/utils';\nimport { SingleTabStopNavigationProvider } from '../../internal/context/single-tab-stop-navigation-context';\nimport { KeyCode } from '../../internal/keycode';\nimport handleKey, { isEventLike } from '../../internal/utils/handle-key';\nimport { nodeBelongs } from '../../internal/utils/node-belongs';\nimport { defaultIsSuppressed, findTableRowByAriaRowIndex, findTableRowCellByAriaColIndex, focusNextElement, getClosestCell, isElementDisabled, isTableCell } from './utils';\n/**\n * Makes table navigable with keyboard commands.\n * See grid-navigation.md\n */\nexport function GridNavigationProvider({\n  keyboardNavigation,\n  pageSize,\n  getTable,\n  children\n}) {\n  const navigationAPI = useRef(null);\n  const gridNavigation = useMemo(() => new GridNavigationProcessor(navigationAPI), []);\n  const getTableStable = useStableCallback(getTable);\n  // Initialize the processor with the table container assuming it is mounted synchronously and only once.\n  useEffect(() => {\n    if (keyboardNavigation) {\n      const table = getTableStable();\n      table && gridNavigation.init(table);\n    }\n    return () => gridNavigation.cleanup();\n  }, [keyboardNavigation, gridNavigation, getTableStable]);\n  // Notify the processor of the props change.\n  useEffect(() => {\n    gridNavigation.update({\n      pageSize\n    });\n  }, [gridNavigation, pageSize]);\n  // Notify the processor of the new render.\n  useEffect(() => {\n    if (keyboardNavigation) {\n      gridNavigation.refresh();\n    }\n  });\n  return React.createElement(SingleTabStopNavigationProvider, {\n    ref: navigationAPI,\n    navigationActive: keyboardNavigation,\n    getNextFocusTarget: gridNavigation.getNextFocusTarget,\n    isElementSuppressed: gridNavigation.isElementSuppressed,\n    onRegisterFocusable: gridNavigation.onRegisterFocusable,\n    onUnregisterActive: gridNavigation.onUnregisterActive\n  }, children);\n}\n/**\n * This helper encapsulates the grid navigation behaviors which are:\n * 1. Responding to keyboard commands and moving the focus accordingly;\n * 2. Muting table interactive elements for only one to be user-focusable at a time;\n * 3. Suppressing the above behaviors when focusing an element inside a dialog or when instructed explicitly.\n */\nclass GridNavigationProcessor {\n  constructor(navigationAPI) {\n    // Props\n    this._pageSize = 0;\n    this._table = null;\n    // State\n    this.focusedCell = null;\n    this.focusInside = false;\n    this.keepUserIndex = false;\n    this.onRegisterFocusable = focusableElement => {\n      var _a;\n      if (!this.focusInside) {\n        return;\n      }\n      // When newly registered element belongs to the focused cell the focus must transition to it.\n      const focusedElement = (_a = this.focusedCell) === null || _a === void 0 ? void 0 : _a.element;\n      if (focusedElement && isTableCell(focusedElement) && focusedElement.contains(focusableElement)) {\n        // Scroll is unnecessary when moving focus from a cell to element within the cell.\n        focusableElement.focus({\n          preventScroll: true\n        });\n      }\n    };\n    this.onUnregisterActive = () => {\n      // If the focused cell appears to be no longer attached to the table we need to re-apply\n      // focus to a cell with the same or closest position.\n      if (this.focusedCell && !nodeBelongs(this.table, this.focusedCell.element)) {\n        this.moveFocusBy(this.focusedCell, {\n          x: 0,\n          y: 0\n        });\n      }\n    };\n    this.getNextFocusTarget = () => {\n      var _a;\n      const cell = this.focusedCell;\n      const firstTableCell = this.table.querySelector('td,th');\n      // A single element of the table is made user-focusable.\n      // It defaults to the first interactive element of the first cell or the first cell itself otherwise.\n      let focusTarget = (_a = firstTableCell && this.getFocusablesFrom(firstTableCell)[0]) !== null && _a !== void 0 ? _a : firstTableCell;\n      // When a navigation-focused element is present in the table it is used for user-navigation instead.\n      if (cell) {\n        focusTarget = this.getNextFocusable(cell, {\n          x: 0,\n          y: 0\n        });\n      }\n      return focusTarget;\n    };\n    this.isElementSuppressed = element => {\n      // Omit calculation as irrelevant until the table receives focus.\n      if (!this.focusedCell) {\n        return false;\n      }\n      return !element || defaultIsSuppressed(element);\n    };\n    this.onFocusin = event => {\n      var _a;\n      this.focusInside = true;\n      if (!(event.target instanceof HTMLElement)) {\n        return;\n      }\n      this.updateFocusedCell(event.target);\n      if (!this.focusedCell) {\n        return;\n      }\n      (_a = this._navigationAPI.current) === null || _a === void 0 ? void 0 : _a.updateFocusTarget();\n      // Focusing on cell is not eligible when it contains focusable elements in the content.\n      // If content focusables are available - move the focus to the first one.\n      const focusedElement = this.focusedCell.element;\n      const nextTarget = isTableCell(focusedElement) ? this.getFocusablesFrom(focusedElement)[0] : null;\n      if (nextTarget) {\n        // Scroll is unnecessary when moving focus from a cell to element within the cell.\n        nextTarget.focus({\n          preventScroll: true\n        });\n      } else {\n        this.keepUserIndex = false;\n      }\n    };\n    this.onFocusout = () => {\n      this.focusInside = false;\n    };\n    this.onKeydown = event => {\n      if (!this.focusedCell) {\n        return;\n      }\n      const keys = [KeyCode.up, KeyCode.down, KeyCode.left, KeyCode.right, KeyCode.pageUp, KeyCode.pageDown, KeyCode.home, KeyCode.end];\n      const ctrlKey = event.ctrlKey ? 1 : 0;\n      const altKey = event.altKey ? 1 : 0;\n      const shiftKey = event.shiftKey ? 1 : 0;\n      const metaKey = event.metaKey ? 1 : 0;\n      const modifiersPressed = ctrlKey + altKey + shiftKey + metaKey;\n      const invalidModifierCombination = modifiersPressed && !event.ctrlKey || event.ctrlKey && event.keyCode !== KeyCode.home && event.keyCode !== KeyCode.end;\n      if (invalidModifierCombination || this.isElementSuppressed(document.activeElement) || !this.isRegistered(document.activeElement) || keys.indexOf(event.keyCode) === -1) {\n        return;\n      }\n      const from = this.focusedCell;\n      event.preventDefault();\n      isEventLike(event) && handleKey(event, {\n        onBlockStart: () => this.moveFocusBy(from, {\n          y: -1,\n          x: 0\n        }),\n        onBlockEnd: () => this.moveFocusBy(from, {\n          y: 1,\n          x: 0\n        }),\n        onInlineStart: () => this.moveFocusBy(from, {\n          y: 0,\n          x: -1\n        }),\n        onInlineEnd: () => this.moveFocusBy(from, {\n          y: 0,\n          x: 1\n        }),\n        onPageUp: () => this.moveFocusBy(from, {\n          y: -this.pageSize,\n          x: 0\n        }),\n        onPageDown: () => this.moveFocusBy(from, {\n          y: this.pageSize,\n          x: 0\n        }),\n        onHome: () => event.ctrlKey ? this.moveFocusBy(from, {\n          y: -Infinity,\n          x: -Infinity\n        }) : this.moveFocusBy(from, {\n          y: 0,\n          x: -Infinity\n        }),\n        onEnd: () => event.ctrlKey ? this.moveFocusBy(from, {\n          y: Infinity,\n          x: Infinity\n        }) : this.moveFocusBy(from, {\n          y: 0,\n          x: Infinity\n        })\n      });\n    };\n    this._navigationAPI = navigationAPI;\n  }\n  init(table) {\n    this._table = table;\n    const controller = new AbortController();\n    this.table.addEventListener('focusin', this.onFocusin, {\n      signal: controller.signal\n    });\n    this.table.addEventListener('focusout', this.onFocusout, {\n      signal: controller.signal\n    });\n    this.table.addEventListener('keydown', this.onKeydown, {\n      signal: controller.signal\n    });\n    this.cleanup = () => {\n      controller.abort();\n    };\n  }\n  cleanup() {\n    // Do nothing before initialized.\n  }\n  update({\n    pageSize\n  }) {\n    this._pageSize = pageSize;\n  }\n  refresh() {\n    // Timeout ensures the newly rendered content elements are registered.\n    setTimeout(() => {\n      var _a, _b;\n      if (this._table) {\n        // Update focused cell indices in case table rows, columns, or firstIndex change.\n        this.updateFocusedCell((_a = this.focusedCell) === null || _a === void 0 ? void 0 : _a.element);\n        (_b = this._navigationAPI.current) === null || _b === void 0 ? void 0 : _b.updateFocusTarget();\n      }\n    }, 0);\n  }\n  get pageSize() {\n    return this._pageSize;\n  }\n  get table() {\n    if (!this._table) {\n      throw new Error('Invariant violation: GridNavigationProcessor is used before initialization.');\n    }\n    return this._table;\n  }\n  moveFocusBy(cell, delta) {\n    // For vertical moves preserve column- and element indices set by user.\n    // It allows keeping indices while moving over disabled actions or cells with colspan > 1.\n    if (delta.y !== 0 && delta.x === 0) {\n      this.keepUserIndex = true;\n    }\n    focusNextElement(this.getNextFocusable(cell, delta));\n  }\n  isRegistered(element) {\n    var _a, _b;\n    return !element || ((_b = (_a = this._navigationAPI.current) === null || _a === void 0 ? void 0 : _a.isRegistered(element)) !== null && _b !== void 0 ? _b : false);\n  }\n  updateFocusedCell(focusedElement) {\n    var _a, _b, _c, _d, _e, _f;\n    if (!focusedElement) {\n      return;\n    }\n    const cellElement = getClosestCell(focusedElement);\n    const rowElement = cellElement === null || cellElement === void 0 ? void 0 : cellElement.closest('tr');\n    if (!cellElement || !rowElement) {\n      return;\n    }\n    const colIndex = parseInt((_a = cellElement.getAttribute('aria-colindex')) !== null && _a !== void 0 ? _a : '');\n    const rowIndex = parseInt((_b = rowElement.getAttribute('aria-rowindex')) !== null && _b !== void 0 ? _b : '');\n    if (isNaN(colIndex) || isNaN(rowIndex)) {\n      return;\n    }\n    const cellFocusables = this.getFocusablesFrom(cellElement);\n    const elementIndex = cellFocusables.indexOf(focusedElement);\n    const prevColIndex = (_d = (_c = this.focusedCell) === null || _c === void 0 ? void 0 : _c.colIndex) !== null && _d !== void 0 ? _d : -1;\n    const prevElementIndex = (_f = (_e = this.focusedCell) === null || _e === void 0 ? void 0 : _e.elementIndex) !== null && _f !== void 0 ? _f : -1;\n    this.focusedCell = {\n      rowIndex,\n      colIndex: this.keepUserIndex && prevColIndex !== -1 ? prevColIndex : colIndex,\n      elementIndex: this.keepUserIndex && prevElementIndex !== -1 ? prevElementIndex : elementIndex,\n      element: focusedElement\n    };\n  }\n  getNextFocusable(from, delta) {\n    var _a;\n    // Find next row to move focus into (can be null if the top/bottom is reached).\n    const targetAriaRowIndex = from.rowIndex + delta.y;\n    const targetRow = findTableRowByAriaRowIndex(this.table, targetAriaRowIndex, delta.y);\n    if (!targetRow) {\n      return null;\n    }\n    // Return next interactive cell content element if available.\n    const cellElement = getClosestCell(from.element);\n    const cellFocusables = cellElement ? this.getFocusablesFrom(cellElement) : [];\n    const nextElementIndex = from.elementIndex + delta.x;\n    const isValidDirection = !!delta.x;\n    const isValidIndex = from.elementIndex !== -1 && 0 <= nextElementIndex && nextElementIndex < cellFocusables.length;\n    const isTargetDifferent = from.element !== cellFocusables[nextElementIndex];\n    if (isValidDirection && isValidIndex && isTargetDifferent) {\n      return cellFocusables[nextElementIndex];\n    }\n    // Find next cell to focus or move focus into (can be null if the left/right edge is reached).\n    const targetAriaColIndex = from.colIndex + delta.x;\n    const targetCell = findTableRowCellByAriaColIndex(targetRow, targetAriaColIndex, delta.x);\n    if (!targetCell) {\n      return null;\n    }\n    // When target cell matches the current cell it means we reached the left or right boundary.\n    if (targetCell === cellElement && delta.x !== 0) {\n      return null;\n    }\n    const targetCellFocusables = this.getFocusablesFrom(targetCell);\n    // When delta.x = 0 keep element index if possible.\n    let focusIndex = from.elementIndex;\n    // Use first element index when moving to the right or to extreme left.\n    if (isFinite(delta.x) && delta.x > 0 || delta.x === -Infinity) {\n      focusIndex = 0;\n    }\n    // Use last element index when moving to the left or to extreme right.\n    if (isFinite(delta.x) && delta.x < 0 || delta.x === Infinity) {\n      focusIndex = targetCellFocusables.length - 1;\n    }\n    return (_a = targetCellFocusables[focusIndex]) !== null && _a !== void 0 ? _a : targetCell;\n  }\n  getFocusablesFrom(target) {\n    const isElementRegistered = element => {\n      var _a;\n      return (_a = this._navigationAPI.current) === null || _a === void 0 ? void 0 : _a.isRegistered(element);\n    };\n    return getAllFocusables(target).filter(el => isElementRegistered(el) && !isElementDisabled(el));\n  }\n}","map":{"version":3,"names":["React","useRef","useEffect","useMemo","useStableCallback","getAllFocusables","SingleTabStopNavigationProvider","KeyCode","handleKey","isEventLike","nodeBelongs","defaultIsSuppressed","findTableRowByAriaRowIndex","findTableRowCellByAriaColIndex","focusNextElement","getClosestCell","isElementDisabled","isTableCell","GridNavigationProvider","keyboardNavigation","pageSize","getTable","children","navigationAPI","gridNavigation","GridNavigationProcessor","getTableStable","table","init","cleanup","update","refresh","createElement","ref","navigationActive","getNextFocusTarget","isElementSuppressed","onRegisterFocusable","onUnregisterActive","constructor","_pageSize","_table","focusedCell","focusInside","keepUserIndex","focusableElement","focusedElement","_a","element","contains","focus","preventScroll","moveFocusBy","x","y","cell","firstTableCell","querySelector","focusTarget","getFocusablesFrom","getNextFocusable","onFocusin","event","target","HTMLElement","updateFocusedCell","_navigationAPI","current","updateFocusTarget","nextTarget","onFocusout","onKeydown","keys","up","down","left","right","pageUp","pageDown","home","end","ctrlKey","altKey","shiftKey","metaKey","modifiersPressed","invalidModifierCombination","keyCode","document","activeElement","isRegistered","indexOf","from","preventDefault","onBlockStart","onBlockEnd","onInlineStart","onInlineEnd","onPageUp","onPageDown","onHome","Infinity","onEnd","controller","AbortController","addEventListener","signal","abort","setTimeout","_b","Error","delta","cellElement","rowElement","closest","colIndex","parseInt","getAttribute","rowIndex","isNaN","cellFocusables","elementIndex","prevColIndex","_d","_c","prevElementIndex","_f","_e","targetAriaRowIndex","targetRow","nextElementIndex","isValidDirection","isValidIndex","length","isTargetDifferent","targetAriaColIndex","targetCell","targetCellFocusables","focusIndex","isFinite","isElementRegistered","filter","el"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/src/table/table-role/grid-navigation.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useRef } from 'react';\nimport { useEffect, useMemo } from 'react';\n\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\n\nimport { getAllFocusables } from '../../internal/components/focus-lock/utils';\nimport {\n  SingleTabStopNavigationAPI,\n  SingleTabStopNavigationProvider,\n} from '../../internal/context/single-tab-stop-navigation-context';\nimport { KeyCode } from '../../internal/keycode';\nimport handleKey, { isEventLike } from '../../internal/utils/handle-key';\nimport { nodeBelongs } from '../../internal/utils/node-belongs';\nimport { FocusedCell, GridNavigationProps } from './interfaces';\nimport {\n  defaultIsSuppressed,\n  findTableRowByAriaRowIndex,\n  findTableRowCellByAriaColIndex,\n  focusNextElement,\n  getClosestCell,\n  isElementDisabled,\n  isTableCell,\n} from './utils';\n\n/**\n * Makes table navigable with keyboard commands.\n * See grid-navigation.md\n */\nexport function GridNavigationProvider({ keyboardNavigation, pageSize, getTable, children }: GridNavigationProps) {\n  const navigationAPI = useRef<SingleTabStopNavigationAPI>(null);\n  const gridNavigation = useMemo(() => new GridNavigationProcessor(navigationAPI), []);\n\n  const getTableStable = useStableCallback(getTable);\n\n  // Initialize the processor with the table container assuming it is mounted synchronously and only once.\n  useEffect(() => {\n    if (keyboardNavigation) {\n      const table = getTableStable();\n      table && gridNavigation.init(table);\n    }\n    return () => gridNavigation.cleanup();\n  }, [keyboardNavigation, gridNavigation, getTableStable]);\n\n  // Notify the processor of the props change.\n  useEffect(() => {\n    gridNavigation.update({ pageSize });\n  }, [gridNavigation, pageSize]);\n\n  // Notify the processor of the new render.\n  useEffect(() => {\n    if (keyboardNavigation) {\n      gridNavigation.refresh();\n    }\n  });\n\n  return (\n    <SingleTabStopNavigationProvider\n      ref={navigationAPI}\n      navigationActive={keyboardNavigation}\n      getNextFocusTarget={gridNavigation.getNextFocusTarget}\n      isElementSuppressed={gridNavigation.isElementSuppressed}\n      onRegisterFocusable={gridNavigation.onRegisterFocusable}\n      onUnregisterActive={gridNavigation.onUnregisterActive}\n    >\n      {children}\n    </SingleTabStopNavigationProvider>\n  );\n}\n\n/**\n * This helper encapsulates the grid navigation behaviors which are:\n * 1. Responding to keyboard commands and moving the focus accordingly;\n * 2. Muting table interactive elements for only one to be user-focusable at a time;\n * 3. Suppressing the above behaviors when focusing an element inside a dialog or when instructed explicitly.\n */\nclass GridNavigationProcessor {\n  // Props\n  private _pageSize = 0;\n  private _table: null | HTMLTableElement = null;\n  private _navigationAPI: { current: null | SingleTabStopNavigationAPI };\n\n  // State\n  private focusedCell: null | FocusedCell = null;\n  private focusInside = false;\n  private keepUserIndex = false;\n\n  constructor(navigationAPI: { current: null | SingleTabStopNavigationAPI }) {\n    this._navigationAPI = navigationAPI;\n  }\n\n  public init(table: HTMLTableElement) {\n    this._table = table;\n    const controller = new AbortController();\n\n    this.table.addEventListener('focusin', this.onFocusin, { signal: controller.signal });\n    this.table.addEventListener('focusout', this.onFocusout, { signal: controller.signal });\n    this.table.addEventListener('keydown', this.onKeydown, { signal: controller.signal });\n\n    this.cleanup = () => {\n      controller.abort();\n    };\n  }\n\n  public cleanup() {\n    // Do nothing before initialized.\n  }\n\n  public update({ pageSize }: { pageSize: number }) {\n    this._pageSize = pageSize;\n  }\n\n  public refresh() {\n    // Timeout ensures the newly rendered content elements are registered.\n    setTimeout(() => {\n      if (this._table) {\n        // Update focused cell indices in case table rows, columns, or firstIndex change.\n        this.updateFocusedCell(this.focusedCell?.element);\n        this._navigationAPI.current?.updateFocusTarget();\n      }\n    }, 0);\n  }\n\n  public onRegisterFocusable = (focusableElement: HTMLElement) => {\n    if (!this.focusInside) {\n      return;\n    }\n    // When newly registered element belongs to the focused cell the focus must transition to it.\n    const focusedElement = this.focusedCell?.element;\n    if (focusedElement && isTableCell(focusedElement) && focusedElement.contains(focusableElement)) {\n      // Scroll is unnecessary when moving focus from a cell to element within the cell.\n      focusableElement.focus({ preventScroll: true });\n    }\n  };\n\n  public onUnregisterActive = () => {\n    // If the focused cell appears to be no longer attached to the table we need to re-apply\n    // focus to a cell with the same or closest position.\n    if (this.focusedCell && !nodeBelongs(this.table, this.focusedCell.element)) {\n      this.moveFocusBy(this.focusedCell, { x: 0, y: 0 });\n    }\n  };\n\n  public getNextFocusTarget = () => {\n    const cell = this.focusedCell;\n    const firstTableCell = this.table.querySelector('td,th') as null | HTMLTableCellElement;\n\n    // A single element of the table is made user-focusable.\n    // It defaults to the first interactive element of the first cell or the first cell itself otherwise.\n    let focusTarget: null | HTMLElement =\n      (firstTableCell && this.getFocusablesFrom(firstTableCell)[0]) ?? firstTableCell;\n\n    // When a navigation-focused element is present in the table it is used for user-navigation instead.\n    if (cell) {\n      focusTarget = this.getNextFocusable(cell, { x: 0, y: 0 });\n    }\n\n    return focusTarget;\n  };\n\n  public isElementSuppressed = (element: null | Element) => {\n    // Omit calculation as irrelevant until the table receives focus.\n    if (!this.focusedCell) {\n      return false;\n    }\n    return !element || defaultIsSuppressed(element);\n  };\n\n  private get pageSize() {\n    return this._pageSize;\n  }\n\n  private get table(): HTMLTableElement {\n    if (!this._table) {\n      throw new Error('Invariant violation: GridNavigationProcessor is used before initialization.');\n    }\n    return this._table;\n  }\n\n  private onFocusin = (event: FocusEvent) => {\n    this.focusInside = true;\n\n    if (!(event.target instanceof HTMLElement)) {\n      return;\n    }\n\n    this.updateFocusedCell(event.target);\n    if (!this.focusedCell) {\n      return;\n    }\n\n    this._navigationAPI.current?.updateFocusTarget();\n\n    // Focusing on cell is not eligible when it contains focusable elements in the content.\n    // If content focusables are available - move the focus to the first one.\n    const focusedElement = this.focusedCell.element;\n    const nextTarget = isTableCell(focusedElement) ? this.getFocusablesFrom(focusedElement)[0] : null;\n    if (nextTarget) {\n      // Scroll is unnecessary when moving focus from a cell to element within the cell.\n      nextTarget.focus({ preventScroll: true });\n    } else {\n      this.keepUserIndex = false;\n    }\n  };\n\n  private onFocusout = () => {\n    this.focusInside = false;\n  };\n\n  private onKeydown = (event: KeyboardEvent) => {\n    if (!this.focusedCell) {\n      return;\n    }\n\n    const keys = [\n      KeyCode.up,\n      KeyCode.down,\n      KeyCode.left,\n      KeyCode.right,\n      KeyCode.pageUp,\n      KeyCode.pageDown,\n      KeyCode.home,\n      KeyCode.end,\n    ];\n    const ctrlKey = event.ctrlKey ? 1 : 0;\n    const altKey = event.altKey ? 1 : 0;\n    const shiftKey = event.shiftKey ? 1 : 0;\n    const metaKey = event.metaKey ? 1 : 0;\n    const modifiersPressed = ctrlKey + altKey + shiftKey + metaKey;\n    const invalidModifierCombination =\n      (modifiersPressed && !event.ctrlKey) ||\n      (event.ctrlKey && event.keyCode !== KeyCode.home && event.keyCode !== KeyCode.end);\n\n    if (\n      invalidModifierCombination ||\n      this.isElementSuppressed(document.activeElement) ||\n      !this.isRegistered(document.activeElement) ||\n      keys.indexOf(event.keyCode) === -1\n    ) {\n      return;\n    }\n\n    const from = this.focusedCell;\n    event.preventDefault();\n\n    isEventLike(event) &&\n      handleKey(event, {\n        onBlockStart: () => this.moveFocusBy(from, { y: -1, x: 0 }),\n        onBlockEnd: () => this.moveFocusBy(from, { y: 1, x: 0 }),\n        onInlineStart: () => this.moveFocusBy(from, { y: 0, x: -1 }),\n        onInlineEnd: () => this.moveFocusBy(from, { y: 0, x: 1 }),\n        onPageUp: () => this.moveFocusBy(from, { y: -this.pageSize, x: 0 }),\n        onPageDown: () => this.moveFocusBy(from, { y: this.pageSize, x: 0 }),\n        onHome: () =>\n          event.ctrlKey\n            ? this.moveFocusBy(from, { y: -Infinity, x: -Infinity })\n            : this.moveFocusBy(from, { y: 0, x: -Infinity }),\n        onEnd: () =>\n          event.ctrlKey\n            ? this.moveFocusBy(from, { y: Infinity, x: Infinity })\n            : this.moveFocusBy(from, { y: 0, x: Infinity }),\n      });\n  };\n\n  private moveFocusBy(cell: FocusedCell, delta: { x: number; y: number }) {\n    // For vertical moves preserve column- and element indices set by user.\n    // It allows keeping indices while moving over disabled actions or cells with colspan > 1.\n    if (delta.y !== 0 && delta.x === 0) {\n      this.keepUserIndex = true;\n    }\n    focusNextElement(this.getNextFocusable(cell, delta));\n  }\n\n  private isRegistered(element: null | Element): boolean {\n    return !element || (this._navigationAPI.current?.isRegistered(element) ?? false);\n  }\n\n  private updateFocusedCell(focusedElement?: HTMLElement): void {\n    if (!focusedElement) {\n      return;\n    }\n\n    const cellElement = getClosestCell(focusedElement);\n    const rowElement = cellElement?.closest('tr');\n    if (!cellElement || !rowElement) {\n      return;\n    }\n\n    const colIndex = parseInt(cellElement.getAttribute('aria-colindex') ?? '');\n    const rowIndex = parseInt(rowElement.getAttribute('aria-rowindex') ?? '');\n    if (isNaN(colIndex) || isNaN(rowIndex)) {\n      return;\n    }\n\n    const cellFocusables = this.getFocusablesFrom(cellElement);\n    const elementIndex = cellFocusables.indexOf(focusedElement);\n\n    const prevColIndex = this.focusedCell?.colIndex ?? -1;\n    const prevElementIndex = this.focusedCell?.elementIndex ?? -1;\n    this.focusedCell = {\n      rowIndex,\n      colIndex: this.keepUserIndex && prevColIndex !== -1 ? prevColIndex : colIndex,\n      elementIndex: this.keepUserIndex && prevElementIndex !== -1 ? prevElementIndex : elementIndex,\n      element: focusedElement,\n    };\n  }\n\n  private getNextFocusable(from: FocusedCell, delta: { y: number; x: number }) {\n    // Find next row to move focus into (can be null if the top/bottom is reached).\n    const targetAriaRowIndex = from.rowIndex + delta.y;\n    const targetRow = findTableRowByAriaRowIndex(this.table, targetAriaRowIndex, delta.y);\n    if (!targetRow) {\n      return null;\n    }\n\n    // Return next interactive cell content element if available.\n    const cellElement = getClosestCell(from.element);\n    const cellFocusables = cellElement ? this.getFocusablesFrom(cellElement) : [];\n    const nextElementIndex = from.elementIndex + delta.x;\n    const isValidDirection = !!delta.x;\n    const isValidIndex = from.elementIndex !== -1 && 0 <= nextElementIndex && nextElementIndex < cellFocusables.length;\n    const isTargetDifferent = from.element !== cellFocusables[nextElementIndex];\n    if (isValidDirection && isValidIndex && isTargetDifferent) {\n      return cellFocusables[nextElementIndex];\n    }\n\n    // Find next cell to focus or move focus into (can be null if the left/right edge is reached).\n    const targetAriaColIndex = from.colIndex + delta.x;\n    const targetCell = findTableRowCellByAriaColIndex(targetRow, targetAriaColIndex, delta.x);\n    if (!targetCell) {\n      return null;\n    }\n\n    // When target cell matches the current cell it means we reached the left or right boundary.\n    if (targetCell === cellElement && delta.x !== 0) {\n      return null;\n    }\n\n    const targetCellFocusables = this.getFocusablesFrom(targetCell);\n\n    // When delta.x = 0 keep element index if possible.\n    let focusIndex = from.elementIndex;\n    // Use first element index when moving to the right or to extreme left.\n    if ((isFinite(delta.x) && delta.x > 0) || delta.x === -Infinity) {\n      focusIndex = 0;\n    }\n    // Use last element index when moving to the left or to extreme right.\n    if ((isFinite(delta.x) && delta.x < 0) || delta.x === Infinity) {\n      focusIndex = targetCellFocusables.length - 1;\n    }\n\n    return targetCellFocusables[focusIndex] ?? targetCell;\n  }\n\n  private getFocusablesFrom(target: HTMLElement) {\n    const isElementRegistered = (element: Element) => this._navigationAPI.current?.isRegistered(element);\n    return getAllFocusables(target).filter(el => isElementRegistered(el) && !isElementDisabled(el));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}