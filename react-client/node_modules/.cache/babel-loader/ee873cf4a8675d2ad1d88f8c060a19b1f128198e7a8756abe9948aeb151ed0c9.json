{"ast":null,"code":"import { compareDates, compareTimestamps } from '../date-utils/compare-dates.js';\nimport { warnOnce } from '../logging.js';\nconst filterUsingOperator = (itemValue, {\n  tokenValue,\n  operator: {\n    operator,\n    match,\n    tokenType\n  }\n}) => {\n  // For match=\"date\" or match=\"datetime\" we expect the value to be a Date object.\n  // The token value is expected to be an ISO date- or datetime string, example:\n  // match(operator=\"=\", token=\"2020-01-01\", value=new Date(\"2020-01-01\")) == true\n  if (match === 'date' || match === 'datetime') {\n    return matchDateValue({\n      tokenValue,\n      itemValue,\n      operator,\n      match\n    });\n  }\n  // For custom match functions there is no expectation to value or token type: the function is supposed\n  // to handle everything. It is recommended to treat both the token and the value as unknowns.\n  else if (typeof match === 'function') {\n    return match(itemValue, tokenValue);\n  } else if (match) {\n    throw new Error('Unsupported `operator.match` type given.');\n  }\n  // For default matching logic we expect the value to be a primitive type or an object that matches by reference.\n  // The token can be an array (tokenType=\"enum\") or a value (tokenType=\"value\" or tokenType=undefined), examples:\n  // match(operator=\"=\", token=\"A\", value=\"A\") == true\n  // match(operator=\"=\", token=[\"A\", \"B\"], value=\"A\") == true\n  return matchPrimitiveValue({\n    tokenValue,\n    itemValue,\n    operator,\n    tokenType\n  });\n};\nfunction matchDateValue({\n  tokenValue,\n  itemValue,\n  operator,\n  match\n}) {\n  const comparator = match === 'date' ? compareDates : compareTimestamps;\n  const comparisonResult = comparator(itemValue, tokenValue);\n  switch (operator) {\n    case '<':\n      return comparisonResult < 0;\n    case '<=':\n      return comparisonResult <= 0;\n    case '>':\n      return comparisonResult > 0;\n    case '>=':\n      return comparisonResult >= 0;\n    case '=':\n      return comparisonResult === 0;\n    case '!=':\n      return comparisonResult !== 0;\n    default:\n      warnOnce(`Unsupported operator \"${operator}\" given for match=\"${match}\".`);\n      return false;\n  }\n}\nfunction matchPrimitiveValue({\n  tokenValue,\n  itemValue,\n  operator,\n  tokenType\n}) {\n  if (tokenType === 'enum') {\n    if (!tokenValue || !Array.isArray(tokenValue)) {\n      warnOnce('The token value must be an array when tokenType==\"enum\".');\n      return false;\n    }\n    switch (operator) {\n      case '=':\n        return tokenValue && tokenValue.includes(itemValue);\n      case '!=':\n        return !tokenValue || !tokenValue.includes(itemValue);\n      default:\n        warnOnce(`Unsupported operator \"${operator}\" given for tokenType==\"enum\".`);\n        return false;\n    }\n  }\n  switch (operator) {\n    case '<':\n      return itemValue < tokenValue;\n    case '<=':\n      return itemValue <= tokenValue;\n    case '>':\n      return itemValue > tokenValue;\n    case '>=':\n      return itemValue >= tokenValue;\n    case '=':\n      // eslint-disable-next-line eqeqeq\n      return itemValue == tokenValue;\n    case '!=':\n      // eslint-disable-next-line eqeqeq\n      return itemValue != tokenValue;\n    case ':':\n      return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) > -1;\n    case '!:':\n      return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) === -1;\n    case '^':\n      return (itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n    case '!^':\n      return !(itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n    // The unsupported operators result in an exception being thrown.\n    // The exception can be avoided if using the match function.\n    default:\n      throw new Error('Unsupported operator given.');\n  }\n}\nfunction freeTextFilter(tokenValue, item, operator, filteringPropertiesMap) {\n  // If the operator is not a negation, we just need one property of the object to match.\n  // If the operator is a negation, we want none of the properties of the object to match.\n  const isNegation = operator.startsWith('!');\n  return Object.keys(filteringPropertiesMap)[isNegation ? 'every' : 'some'](propertyKey => {\n    const {\n      operators\n    } = filteringPropertiesMap[propertyKey];\n    const propertyOperator = operators[operator];\n    if (!propertyOperator) {\n      return isNegation;\n    }\n    return filterUsingOperator(item[propertyKey], {\n      tokenValue,\n      operator: propertyOperator\n    });\n  });\n}\nfunction filterByToken(token, item, filteringPropertiesMap) {\n  if (token.propertyKey) {\n    // token refers to a unknown property or uses an unsupported operator\n    if (!(token.propertyKey in filteringPropertiesMap) || !(token.operator in filteringPropertiesMap[token.propertyKey].operators)) {\n      return false;\n    }\n    const property = filteringPropertiesMap[token.propertyKey];\n    const operator = property.operators[token.operator];\n    const itemValue = (operator === null || operator === void 0 ? void 0 : operator.match) ? item[token.propertyKey] : fixupFalsyValues(item[token.propertyKey]);\n    return filterUsingOperator(itemValue, {\n      tokenValue: token.value,\n      operator: operator !== null && operator !== void 0 ? operator : {\n        operator: token.operator\n      }\n    });\n  }\n  return freeTextFilter(token.value, item, token.operator, filteringPropertiesMap);\n}\nfunction defaultFilteringFunction(filteringPropertiesMap) {\n  return (item, query) => {\n    var _a;\n    function evaluate(tokenOrGroup) {\n      if ('operation' in tokenOrGroup) {\n        let result = tokenOrGroup.operation === 'and' ? true : !tokenOrGroup.tokens.length;\n        for (const group of tokenOrGroup.tokens) {\n          result = tokenOrGroup.operation === 'and' ? result && evaluate(group) : result || evaluate(group);\n        }\n        return result;\n      } else {\n        return filterByToken(tokenOrGroup, item, filteringPropertiesMap);\n      }\n    }\n    return evaluate({\n      operation: query.operation,\n      tokens: (_a = query.tokenGroups) !== null && _a !== void 0 ? _a : query.tokens\n    });\n  };\n}\nexport function createPropertyFilterPredicate(propertyFiltering, query = {\n  tokens: [],\n  operation: 'and'\n}) {\n  if (!propertyFiltering) {\n    return null;\n  }\n  const filteringPropertiesMap = propertyFiltering.filteringProperties.reduce((acc, {\n    key,\n    operators,\n    defaultOperator\n  }) => {\n    const operatorMap = {\n      [defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '=']: {\n        operator: defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '='\n      }\n    };\n    operators === null || operators === void 0 ? void 0 : operators.forEach(op => {\n      if (typeof op === 'string') {\n        operatorMap[op] = {\n          operator: op\n        };\n      } else {\n        operatorMap[op.operator] = {\n          operator: op.operator,\n          match: op.match,\n          tokenType: op.tokenType\n        };\n      }\n    });\n    acc[key] = {\n      operators: operatorMap\n    };\n    return acc;\n  }, {});\n  const filteringFunction = propertyFiltering.filteringFunction || defaultFilteringFunction(filteringPropertiesMap);\n  return item => filteringFunction(item, query);\n}\nexport const fixupFalsyValues = value => {\n  if (typeof value === 'boolean') {\n    return value + '';\n  }\n  if (value || value === 0) {\n    return value;\n  }\n  return '';\n};","map":{"version":3,"names":["compareDates","compareTimestamps","warnOnce","filterUsingOperator","itemValue","tokenValue","operator","match","tokenType","matchDateValue","Error","matchPrimitiveValue","comparator","comparisonResult","Array","isArray","includes","toLowerCase","indexOf","startsWith","freeTextFilter","item","filteringPropertiesMap","isNegation","Object","keys","propertyKey","operators","propertyOperator","filterByToken","token","property","fixupFalsyValues","value","defaultFilteringFunction","query","_a","evaluate","tokenOrGroup","result","operation","tokens","length","group","tokenGroups","createPropertyFilterPredicate","propertyFiltering","filteringProperties","reduce","acc","key","defaultOperator","operatorMap","forEach","op","filteringFunction"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/@cloudscape-design/collection-hooks/mjs/operations/property-filter.js"],"sourcesContent":["import { compareDates, compareTimestamps } from '../date-utils/compare-dates.js';\nimport { warnOnce } from '../logging.js';\nconst filterUsingOperator = (itemValue, { tokenValue, operator: { operator, match, tokenType }, }) => {\n    // For match=\"date\" or match=\"datetime\" we expect the value to be a Date object.\n    // The token value is expected to be an ISO date- or datetime string, example:\n    // match(operator=\"=\", token=\"2020-01-01\", value=new Date(\"2020-01-01\")) == true\n    if (match === 'date' || match === 'datetime') {\n        return matchDateValue({ tokenValue, itemValue, operator, match });\n    }\n    // For custom match functions there is no expectation to value or token type: the function is supposed\n    // to handle everything. It is recommended to treat both the token and the value as unknowns.\n    else if (typeof match === 'function') {\n        return match(itemValue, tokenValue);\n    }\n    else if (match) {\n        throw new Error('Unsupported `operator.match` type given.');\n    }\n    // For default matching logic we expect the value to be a primitive type or an object that matches by reference.\n    // The token can be an array (tokenType=\"enum\") or a value (tokenType=\"value\" or tokenType=undefined), examples:\n    // match(operator=\"=\", token=\"A\", value=\"A\") == true\n    // match(operator=\"=\", token=[\"A\", \"B\"], value=\"A\") == true\n    return matchPrimitiveValue({ tokenValue, itemValue, operator, tokenType });\n};\nfunction matchDateValue({ tokenValue, itemValue, operator, match, }) {\n    const comparator = match === 'date' ? compareDates : compareTimestamps;\n    const comparisonResult = comparator(itemValue, tokenValue);\n    switch (operator) {\n        case '<':\n            return comparisonResult < 0;\n        case '<=':\n            return comparisonResult <= 0;\n        case '>':\n            return comparisonResult > 0;\n        case '>=':\n            return comparisonResult >= 0;\n        case '=':\n            return comparisonResult === 0;\n        case '!=':\n            return comparisonResult !== 0;\n        default:\n            warnOnce(`Unsupported operator \"${operator}\" given for match=\"${match}\".`);\n            return false;\n    }\n}\nfunction matchPrimitiveValue({ tokenValue, itemValue, operator, tokenType, }) {\n    if (tokenType === 'enum') {\n        if (!tokenValue || !Array.isArray(tokenValue)) {\n            warnOnce('The token value must be an array when tokenType==\"enum\".');\n            return false;\n        }\n        switch (operator) {\n            case '=':\n                return tokenValue && tokenValue.includes(itemValue);\n            case '!=':\n                return !tokenValue || !tokenValue.includes(itemValue);\n            default:\n                warnOnce(`Unsupported operator \"${operator}\" given for tokenType==\"enum\".`);\n                return false;\n        }\n    }\n    switch (operator) {\n        case '<':\n            return itemValue < tokenValue;\n        case '<=':\n            return itemValue <= tokenValue;\n        case '>':\n            return itemValue > tokenValue;\n        case '>=':\n            return itemValue >= tokenValue;\n        case '=':\n            // eslint-disable-next-line eqeqeq\n            return itemValue == tokenValue;\n        case '!=':\n            // eslint-disable-next-line eqeqeq\n            return itemValue != tokenValue;\n        case ':':\n            return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) > -1;\n        case '!:':\n            return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) === -1;\n        case '^':\n            return (itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n        case '!^':\n            return !(itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n        // The unsupported operators result in an exception being thrown.\n        // The exception can be avoided if using the match function.\n        default:\n            throw new Error('Unsupported operator given.');\n    }\n}\nfunction freeTextFilter(tokenValue, item, operator, filteringPropertiesMap) {\n    // If the operator is not a negation, we just need one property of the object to match.\n    // If the operator is a negation, we want none of the properties of the object to match.\n    const isNegation = operator.startsWith('!');\n    return Object.keys(filteringPropertiesMap)[isNegation ? 'every' : 'some'](propertyKey => {\n        const { operators } = filteringPropertiesMap[propertyKey];\n        const propertyOperator = operators[operator];\n        if (!propertyOperator) {\n            return isNegation;\n        }\n        return filterUsingOperator(item[propertyKey], { tokenValue, operator: propertyOperator });\n    });\n}\nfunction filterByToken(token, item, filteringPropertiesMap) {\n    if (token.propertyKey) {\n        // token refers to a unknown property or uses an unsupported operator\n        if (!(token.propertyKey in filteringPropertiesMap) ||\n            !(token.operator in filteringPropertiesMap[token.propertyKey].operators)) {\n            return false;\n        }\n        const property = filteringPropertiesMap[token.propertyKey];\n        const operator = property.operators[token.operator];\n        const itemValue = (operator === null || operator === void 0 ? void 0 : operator.match)\n            ? item[token.propertyKey]\n            : fixupFalsyValues(item[token.propertyKey]);\n        return filterUsingOperator(itemValue, {\n            tokenValue: token.value,\n            operator: operator !== null && operator !== void 0 ? operator : { operator: token.operator },\n        });\n    }\n    return freeTextFilter(token.value, item, token.operator, filteringPropertiesMap);\n}\nfunction defaultFilteringFunction(filteringPropertiesMap) {\n    return (item, query) => {\n        var _a;\n        function evaluate(tokenOrGroup) {\n            if ('operation' in tokenOrGroup) {\n                let result = tokenOrGroup.operation === 'and' ? true : !tokenOrGroup.tokens.length;\n                for (const group of tokenOrGroup.tokens) {\n                    result = tokenOrGroup.operation === 'and' ? result && evaluate(group) : result || evaluate(group);\n                }\n                return result;\n            }\n            else {\n                return filterByToken(tokenOrGroup, item, filteringPropertiesMap);\n            }\n        }\n        return evaluate({\n            operation: query.operation,\n            tokens: (_a = query.tokenGroups) !== null && _a !== void 0 ? _a : query.tokens,\n        });\n    };\n}\nexport function createPropertyFilterPredicate(propertyFiltering, query = { tokens: [], operation: 'and' }) {\n    if (!propertyFiltering) {\n        return null;\n    }\n    const filteringPropertiesMap = propertyFiltering.filteringProperties.reduce((acc, { key, operators, defaultOperator }) => {\n        const operatorMap = { [defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '=']: { operator: defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '=' } };\n        operators === null || operators === void 0 ? void 0 : operators.forEach(op => {\n            if (typeof op === 'string') {\n                operatorMap[op] = { operator: op };\n            }\n            else {\n                operatorMap[op.operator] = { operator: op.operator, match: op.match, tokenType: op.tokenType };\n            }\n        });\n        acc[key] = { operators: operatorMap };\n        return acc;\n    }, {});\n    const filteringFunction = propertyFiltering.filteringFunction || defaultFilteringFunction(filteringPropertiesMap);\n    return item => filteringFunction(item, query);\n}\nexport const fixupFalsyValues = (value) => {\n    if (typeof value === 'boolean') {\n        return value + '';\n    }\n    if (value || value === 0) {\n        return value;\n    }\n    return '';\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}