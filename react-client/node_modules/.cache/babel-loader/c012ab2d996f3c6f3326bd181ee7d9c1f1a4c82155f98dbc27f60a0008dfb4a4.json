{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar _ScrollLock_timeoutId, _ScrollLock_scrollLeft, _ScrollLock_active;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { useEffect } from 'react';\nimport bodyCellStyles from './body-cell/styles.css.js';\nconst stickyCellSelector = `.${bodyCellStyles['sticky-cell']}`;\n// The scroll lock timeout value was determined empirically.\n// It is small enough to not interfere with sequential user events, and long enough\n// to ensure the browser-triggered scroll event occurs.\nconst scrollLockTimeout = 50;\n// The function provides a workaround for a Chrome issue causing unexpected scroll when clicking on interactive elements\n// inside sticky table cells.\n// When an interactive element (cell editor button, row selector, or a custom interactive button or link) is clicked, it receives\n// focus. The browser then tries to ensure the focused element is visible on screen, and it scrolls the element into view as needed.\n// In Chrome, this scrolling also occurs when clicking an interactive element inside a sticky cell, despite it being fully visible.\n// This causes an unneeded and unexpected scroll of the table wrapper towards the sticky element (on the left or on the right).\n//\n// Note: If moving focus to an interactive element using the keyboard, the automatic scroll still happens.\n// That is because the implemented workaround is not suitable for focusin events due to a difference in events order.\nexport function usePreventStickyClickScroll(wrapperRefObject) {\n  useEffect(() => {\n    if (wrapperRefObject.current) {\n      const wrapperEl = wrapperRefObject.current;\n      const scrollLock = new ScrollLock();\n      // For click events inside sticky cells we capture the table wrapper scroll offset.\n      // This is used to reset the browser-enforced scrolling that is to follow.\n      // The scroll lock is automatically cleared after a short delay.\n      const onClick = event => {\n        if (event.target && event.target instanceof HTMLElement && (event.target.matches(stickyCellSelector) || event.target.closest(stickyCellSelector))) {\n          scrollLock.set(wrapperEl.scrollLeft);\n        }\n      };\n      wrapperEl.addEventListener('click', onClick);\n      // We cannot prevent the browser-issued scroll events from happening, and cannot cancel the default behavior.\n      // Instead, if we detect a scroll event that immediately follows a click inside a sticky cell, we negate the\n      // effect of it by resetting the wrapper scroll offset to its previous value.\n      const onScroll = () => {\n        if (scrollLock.active) {\n          wrapperEl.scrollLeft = scrollLock.scrollLeft;\n          scrollLock.clear();\n        }\n      };\n      wrapperEl.addEventListener('scroll', onScroll);\n      return () => {\n        wrapperEl.removeEventListener('click', onClick);\n        wrapperEl.removeEventListener('scroll', onScroll);\n      };\n    }\n  }, [wrapperRefObject]);\n}\nclass ScrollLock {\n  constructor() {\n    _ScrollLock_timeoutId.set(this, setTimeout(() => {}, 0));\n    _ScrollLock_scrollLeft.set(this, 0);\n    _ScrollLock_active.set(this, false);\n  }\n  set(scrollLeft) {\n    if (!__classPrivateFieldGet(this, _ScrollLock_active, \"f\")) {\n      __classPrivateFieldSet(this, _ScrollLock_active, true, \"f\");\n      __classPrivateFieldSet(this, _ScrollLock_scrollLeft, scrollLeft, \"f\");\n      __classPrivateFieldSet(this, _ScrollLock_timeoutId, setTimeout(() => __classPrivateFieldSet(this, _ScrollLock_active, false, \"f\"), scrollLockTimeout), \"f\");\n    }\n  }\n  clear() {\n    __classPrivateFieldSet(this, _ScrollLock_active, false, \"f\");\n    clearTimeout(__classPrivateFieldGet(this, _ScrollLock_timeoutId, \"f\"));\n  }\n  get active() {\n    return __classPrivateFieldGet(this, _ScrollLock_active, \"f\");\n  }\n  get scrollLeft() {\n    return __classPrivateFieldGet(this, _ScrollLock_scrollLeft, \"f\");\n  }\n}\n_ScrollLock_timeoutId = new WeakMap(), _ScrollLock_scrollLeft = new WeakMap(), _ScrollLock_active = new WeakMap();","map":{"version":3,"names":["useEffect","bodyCellStyles","stickyCellSelector","scrollLockTimeout","usePreventStickyClickScroll","wrapperRefObject","current","wrapperEl","scrollLock","ScrollLock","onClick","event","target","HTMLElement","matches","closest","set","scrollLeft","addEventListener","onScroll","active","clear","removeEventListener","constructor","_ScrollLock_timeoutId","setTimeout","_ScrollLock_scrollLeft","_ScrollLock_active","__classPrivateFieldGet","__classPrivateFieldSet","clearTimeout"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/src/table/use-prevent-sticky-click-scroll.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useEffect } from 'react';\n\nimport bodyCellStyles from './body-cell/styles.css.js';\n\nconst stickyCellSelector = `.${bodyCellStyles['sticky-cell']}`;\n\n// The scroll lock timeout value was determined empirically.\n// It is small enough to not interfere with sequential user events, and long enough\n// to ensure the browser-triggered scroll event occurs.\nconst scrollLockTimeout = 50;\n\n// The function provides a workaround for a Chrome issue causing unexpected scroll when clicking on interactive elements\n// inside sticky table cells.\n// When an interactive element (cell editor button, row selector, or a custom interactive button or link) is clicked, it receives\n// focus. The browser then tries to ensure the focused element is visible on screen, and it scrolls the element into view as needed.\n// In Chrome, this scrolling also occurs when clicking an interactive element inside a sticky cell, despite it being fully visible.\n// This causes an unneeded and unexpected scroll of the table wrapper towards the sticky element (on the left or on the right).\n//\n// Note: If moving focus to an interactive element using the keyboard, the automatic scroll still happens.\n// That is because the implemented workaround is not suitable for focusin events due to a difference in events order.\nexport function usePreventStickyClickScroll(wrapperRefObject: React.RefObject<HTMLDivElement>) {\n  useEffect(() => {\n    if (wrapperRefObject.current) {\n      const wrapperEl = wrapperRefObject.current;\n      const scrollLock = new ScrollLock();\n\n      // For click events inside sticky cells we capture the table wrapper scroll offset.\n      // This is used to reset the browser-enforced scrolling that is to follow.\n      // The scroll lock is automatically cleared after a short delay.\n      const onClick = (event: Event) => {\n        if (\n          event.target &&\n          event.target instanceof HTMLElement &&\n          (event.target.matches(stickyCellSelector) || event.target.closest(stickyCellSelector))\n        ) {\n          scrollLock.set(wrapperEl.scrollLeft);\n        }\n      };\n      wrapperEl.addEventListener('click', onClick);\n\n      // We cannot prevent the browser-issued scroll events from happening, and cannot cancel the default behavior.\n      // Instead, if we detect a scroll event that immediately follows a click inside a sticky cell, we negate the\n      // effect of it by resetting the wrapper scroll offset to its previous value.\n      const onScroll = () => {\n        if (scrollLock.active) {\n          wrapperEl.scrollLeft = scrollLock.scrollLeft;\n          scrollLock.clear();\n        }\n      };\n      wrapperEl.addEventListener('scroll', onScroll);\n\n      return () => {\n        wrapperEl.removeEventListener('click', onClick);\n        wrapperEl.removeEventListener('scroll', onScroll);\n      };\n    }\n  }, [wrapperRefObject]);\n}\n\nclass ScrollLock {\n  #timeoutId = setTimeout(() => {}, 0);\n  #scrollLeft = 0;\n  #active = false;\n\n  public set(scrollLeft: number) {\n    if (!this.#active) {\n      this.#active = true;\n      this.#scrollLeft = scrollLeft;\n      this.#timeoutId = setTimeout(() => (this.#active = false), scrollLockTimeout);\n    }\n  }\n\n  public clear() {\n    this.#active = false;\n    clearTimeout(this.#timeoutId);\n  }\n\n  public get active() {\n    return this.#active;\n  }\n\n  public get scrollLeft() {\n    return this.#scrollLeft;\n  }\n}\n"],"mappings":"AAAA;AACA;;;AAEA,SAASA,SAAS,QAAQ,OAAO;AAEjC,OAAOC,cAAc,MAAM,2BAA2B;AAEtD,MAAMC,kBAAkB,GAAG,IAAID,cAAc,CAAC,aAAa,CAAC,EAAE;AAE9D;AACA;AACA;AACA,MAAME,iBAAiB,GAAG,EAAE;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM,SAAUC,2BAA2BA,CAACC,gBAAiD;EAC3FL,SAAS,CAAC,MAAK;IACb,IAAIK,gBAAgB,CAACC,OAAO,EAAE;MAC5B,MAAMC,SAAS,GAAGF,gBAAgB,CAACC,OAAO;MAC1C,MAAME,UAAU,GAAG,IAAIC,UAAU,EAAE;MAEnC;MACA;MACA;MACA,MAAMC,OAAO,GAAIC,KAAY,IAAI;QAC/B,IACEA,KAAK,CAACC,MAAM,IACZD,KAAK,CAACC,MAAM,YAAYC,WAAW,KAClCF,KAAK,CAACC,MAAM,CAACE,OAAO,CAACZ,kBAAkB,CAAC,IAAIS,KAAK,CAACC,MAAM,CAACG,OAAO,CAACb,kBAAkB,CAAC,CAAC,EACtF;UACAM,UAAU,CAACQ,GAAG,CAACT,SAAS,CAACU,UAAU,CAAC;;MAExC,CAAC;MACDV,SAAS,CAACW,gBAAgB,CAAC,OAAO,EAAER,OAAO,CAAC;MAE5C;MACA;MACA;MACA,MAAMS,QAAQ,GAAGA,CAAA,KAAK;QACpB,IAAIX,UAAU,CAACY,MAAM,EAAE;UACrBb,SAAS,CAACU,UAAU,GAAGT,UAAU,CAACS,UAAU;UAC5CT,UAAU,CAACa,KAAK,EAAE;;MAEtB,CAAC;MACDd,SAAS,CAACW,gBAAgB,CAAC,QAAQ,EAAEC,QAAQ,CAAC;MAE9C,OAAO,MAAK;QACVZ,SAAS,CAACe,mBAAmB,CAAC,OAAO,EAAEZ,OAAO,CAAC;QAC/CH,SAAS,CAACe,mBAAmB,CAAC,QAAQ,EAAEH,QAAQ,CAAC;MACnD,CAAC;;EAEL,CAAC,EAAE,CAACd,gBAAgB,CAAC,CAAC;AACxB;AAEA,MAAMI,UAAU;EAAhBc,YAAA;IACEC,qBAAA,CAAAR,GAAA,OAAaS,UAAU,CAAC,MAAK,CAAE,CAAC,EAAE,CAAC,CAAC;IACpCC,sBAAA,CAAAV,GAAA,OAAc,CAAC;IACfW,kBAAA,CAAAX,GAAA,OAAU,KAAK;EAsBjB;EApBSA,GAAGA,CAACC,UAAkB;IAC3B,IAAI,CAACW,sBAAA,KAAI,EAAAD,kBAAA,MAAQ,EAAE;MACjBE,sBAAA,KAAI,EAAAF,kBAAA,EAAW,IAAI;MACnBE,sBAAA,KAAI,EAAAH,sBAAA,EAAeT,UAAU;MAC7BY,sBAAA,KAAI,EAAAL,qBAAA,EAAcC,UAAU,CAAC,MAAOI,sBAAA,KAAI,EAAAF,kBAAA,EAAW,KAAK,MAAC,EAAExB,iBAAiB,CAAC;;EAEjF;EAEOkB,KAAKA,CAAA;IACVQ,sBAAA,KAAI,EAAAF,kBAAA,EAAW,KAAK;IACpBG,YAAY,CAACF,sBAAA,KAAI,EAAAJ,qBAAA,MAAW,CAAC;EAC/B;EAEA,IAAWJ,MAAMA,CAAA;IACf,OAAOQ,sBAAA,KAAI,EAAAD,kBAAA,MAAQ;EACrB;EAEA,IAAWV,UAAUA,CAAA;IACnB,OAAOW,sBAAA,KAAI,EAAAF,sBAAA,MAAY;EACzB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}