{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { createContext, useCallback, useEffect, useLayoutEffect, useState } from 'react';\nimport { findUpUntil } from '@cloudscape-design/component-toolkit/dom';\nimport * as tokens from '../internal/generated/styles/tokens';\nimport { useMobile } from '../internal/hooks/use-mobile';\nimport globalVars from '../internal/styles/global-vars';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\nexport function computeOffset({\n  isMobile,\n  __stickyOffset,\n  __mobileStickyOffset,\n  hasInnerOverflowParents,\n  __additionalOffset\n}) {\n  const localOffset = isMobile ? (__stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : 0) - (__mobileStickyOffset !== null && __mobileStickyOffset !== void 0 ? __mobileStickyOffset : 0) : __stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : 0;\n  if (hasInnerOverflowParents || __stickyOffset !== undefined) {\n    return `${localOffset}px`;\n  }\n  const globalOffset = `var(${globalVars.stickyVerticalTopOffset}, 0px)`;\n  return `calc(${globalOffset} + ${localOffset}px + ${__additionalOffset ? tokens.spaceScaledS : '0px'})`;\n}\nexport const StickyHeaderContext = createContext({\n  isStuck: false,\n  isStuckAtBottom: false\n});\nexport const useStickyHeader = (rootRef, headerRef, __stickyHeader, __stickyOffset, __mobileStickyOffset, __disableMobile, __additionalOffset = false) => {\n  const isMobile = useMobile();\n  const disableSticky = isMobile && __disableMobile;\n  const isSticky = !disableSticky && !!__stickyHeader;\n  // If it has overflow parents inside the app layout, we shouldn't apply a sticky offset.\n  const [hasInnerOverflowParents, setHasInnerOverflowParents] = useState(false);\n  const [isStuck, setIsStuck] = useState(false);\n  const [isStuckAtBottom, setIsStuckAtBottom] = useState(false);\n  useLayoutEffect(() => {\n    if (rootRef.current) {\n      const overflowParents = getOverflowParents(rootRef.current);\n      const mainElement = findUpUntil(rootRef.current, elem => elem.tagName === 'MAIN');\n      // In both versions of the app layout, the scrolling element for disableBodyScroll\n      // is the <main>. If the closest overflow parent is also the closest <main> and we have\n      // offset values, it's safe to assume that it's the app layout scroll root and we\n      // should stop there.\n      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);\n    }\n  }, [rootRef]);\n  const computedOffset = computeOffset({\n    isMobile,\n    __stickyOffset,\n    __mobileStickyOffset,\n    hasInnerOverflowParents,\n    __additionalOffset\n  });\n  const stickyStyles = isSticky ? {\n    style: {\n      top: computedOffset\n    }\n  } : {};\n  // \"stuck\" state, when the header has moved from its original posititon has a\n  // box-shadow, applied here by a \"header-stuck\" className\n  const checkIfStuck = useCallback(({\n    isTrusted,\n    target,\n    type\n  }) => {\n    if (type === 'resize' && target === window && !isTrusted) {\n      // The window size didn't actually change, it was a synthetic event\n      return;\n    }\n    if (rootRef.current && headerRef.current) {\n      const rootTopBorderWidth = parseFloat(getComputedStyle(rootRef.current).borderTopWidth) || 0;\n      // Using Math.round to adjust for rounding errors in floating-point arithmetic and timing issues\n      const rootTop = Math.round(rootRef.current.getBoundingClientRect().top + rootTopBorderWidth);\n      const headerTop = Math.round(headerRef.current.getBoundingClientRect().top);\n      if (rootTop < headerTop) {\n        setIsStuck(true);\n      } else {\n        setIsStuck(false);\n      }\n      const rootBottom = Math.round(rootRef.current.getBoundingClientRect().bottom - rootTopBorderWidth);\n      const headerBottom = Math.round(headerRef.current.getBoundingClientRect().bottom);\n      if (rootBottom <= headerBottom) {\n        setIsStuckAtBottom(true);\n      } else {\n        setIsStuckAtBottom(false);\n      }\n    }\n  }, [rootRef, headerRef]);\n  useEffect(() => {\n    if (isSticky) {\n      const controller = new AbortController();\n      window.addEventListener('scroll', checkIfStuck, {\n        capture: true,\n        signal: controller.signal\n      });\n      window.addEventListener('resize', checkIfStuck, {\n        signal: controller.signal\n      });\n      return () => {\n        controller.abort();\n      };\n    }\n  }, [isSticky, checkIfStuck]);\n  return {\n    isSticky,\n    isStuck,\n    isStuckAtBottom,\n    stickyStyles\n  };\n};","map":{"version":3,"names":["createContext","useCallback","useEffect","useLayoutEffect","useState","findUpUntil","tokens","useMobile","globalVars","getOverflowParents","computeOffset","isMobile","__stickyOffset","__mobileStickyOffset","hasInnerOverflowParents","__additionalOffset","localOffset","undefined","globalOffset","stickyVerticalTopOffset","spaceScaledS","StickyHeaderContext","isStuck","isStuckAtBottom","useStickyHeader","rootRef","headerRef","__stickyHeader","__disableMobile","disableSticky","isSticky","setHasInnerOverflowParents","setIsStuck","setIsStuckAtBottom","current","overflowParents","mainElement","elem","tagName","length","computedOffset","stickyStyles","style","top","checkIfStuck","isTrusted","target","type","window","rootTopBorderWidth","parseFloat","getComputedStyle","borderTopWidth","rootTop","Math","round","getBoundingClientRect","headerTop","rootBottom","bottom","headerBottom","controller","AbortController","addEventListener","capture","signal","abort"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/src/container/use-sticky-header.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { createContext, RefObject, useCallback, useEffect, useLayoutEffect, useState } from 'react';\n\nimport { findUpUntil } from '@cloudscape-design/component-toolkit/dom';\n\nimport * as tokens from '../internal/generated/styles/tokens';\nimport { useMobile } from '../internal/hooks/use-mobile';\nimport globalVars from '../internal/styles/global-vars';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\n\ninterface StickyHeaderContextProps {\n  isStuck: boolean;\n  isStuckAtBottom: boolean;\n}\n\ninterface ComputeOffsetProps {\n  isMobile: boolean;\n  __stickyOffset?: number;\n  __mobileStickyOffset?: number;\n  hasInnerOverflowParents: boolean;\n  __additionalOffset?: boolean;\n}\n\nexport function computeOffset({\n  isMobile,\n  __stickyOffset,\n  __mobileStickyOffset,\n  hasInnerOverflowParents,\n  __additionalOffset,\n}: ComputeOffsetProps): string {\n  const localOffset = isMobile ? (__stickyOffset ?? 0) - (__mobileStickyOffset ?? 0) : __stickyOffset ?? 0;\n  if (hasInnerOverflowParents || __stickyOffset !== undefined) {\n    return `${localOffset}px`;\n  }\n  const globalOffset = `var(${globalVars.stickyVerticalTopOffset}, 0px)`;\n\n  return `calc(${globalOffset} + ${localOffset}px + ${__additionalOffset ? tokens.spaceScaledS : '0px'})`;\n}\n\nexport const StickyHeaderContext = createContext<StickyHeaderContextProps>({\n  isStuck: false,\n  isStuckAtBottom: false,\n});\n\nexport const useStickyHeader = (\n  rootRef: RefObject<HTMLDivElement>,\n  headerRef: RefObject<HTMLDivElement>,\n  __stickyHeader?: boolean,\n  __stickyOffset?: number,\n  __mobileStickyOffset?: number,\n  __disableMobile?: boolean,\n  __additionalOffset = false\n) => {\n  const isMobile = useMobile();\n  const disableSticky = isMobile && __disableMobile;\n  const isSticky = !disableSticky && !!__stickyHeader;\n\n  // If it has overflow parents inside the app layout, we shouldn't apply a sticky offset.\n  const [hasInnerOverflowParents, setHasInnerOverflowParents] = useState(false);\n  const [isStuck, setIsStuck] = useState(false);\n  const [isStuckAtBottom, setIsStuckAtBottom] = useState(false);\n\n  useLayoutEffect(() => {\n    if (rootRef.current) {\n      const overflowParents = getOverflowParents(rootRef.current);\n      const mainElement = findUpUntil(rootRef.current, elem => elem.tagName === 'MAIN');\n\n      // In both versions of the app layout, the scrolling element for disableBodyScroll\n      // is the <main>. If the closest overflow parent is also the closest <main> and we have\n      // offset values, it's safe to assume that it's the app layout scroll root and we\n      // should stop there.\n      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);\n    }\n  }, [rootRef]);\n\n  const computedOffset = computeOffset({\n    isMobile,\n    __stickyOffset,\n    __mobileStickyOffset,\n    hasInnerOverflowParents,\n    __additionalOffset,\n  });\n\n  const stickyStyles = isSticky\n    ? {\n        style: {\n          top: computedOffset,\n        },\n      }\n    : {};\n\n  // \"stuck\" state, when the header has moved from its original posititon has a\n  // box-shadow, applied here by a \"header-stuck\" className\n  const checkIfStuck = useCallback(\n    ({ isTrusted, target, type }) => {\n      if (type === 'resize' && target === window && !isTrusted) {\n        // The window size didn't actually change, it was a synthetic event\n        return;\n      }\n      if (rootRef.current && headerRef.current) {\n        const rootTopBorderWidth = parseFloat(getComputedStyle(rootRef.current).borderTopWidth) || 0;\n\n        // Using Math.round to adjust for rounding errors in floating-point arithmetic and timing issues\n        const rootTop = Math.round(rootRef.current.getBoundingClientRect().top + rootTopBorderWidth);\n        const headerTop = Math.round(headerRef.current.getBoundingClientRect().top);\n        if (rootTop < headerTop) {\n          setIsStuck(true);\n        } else {\n          setIsStuck(false);\n        }\n\n        const rootBottom = Math.round(rootRef.current.getBoundingClientRect().bottom - rootTopBorderWidth);\n        const headerBottom = Math.round(headerRef.current.getBoundingClientRect().bottom);\n        if (rootBottom <= headerBottom) {\n          setIsStuckAtBottom(true);\n        } else {\n          setIsStuckAtBottom(false);\n        }\n      }\n    },\n    [rootRef, headerRef]\n  );\n\n  useEffect(() => {\n    if (isSticky) {\n      const controller = new AbortController();\n      window.addEventListener('scroll', checkIfStuck, { capture: true, signal: controller.signal });\n      window.addEventListener('resize', checkIfStuck, { signal: controller.signal });\n      return () => {\n        controller.abort();\n      };\n    }\n  }, [isSticky, checkIfStuck]);\n  return {\n    isSticky,\n    isStuck,\n    isStuckAtBottom,\n    stickyStyles,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}