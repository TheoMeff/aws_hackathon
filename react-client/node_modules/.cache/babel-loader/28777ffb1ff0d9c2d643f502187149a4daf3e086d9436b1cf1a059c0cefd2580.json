{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useRef, useState } from 'react';\nimport { closestCenter, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { hasSortableData } from '@dnd-kit/sortable';\nimport { KeyboardSensor } from './keyboard-sensor';\nvar KeyboardCode;\n(function (KeyboardCode) {\n  KeyboardCode[\"Space\"] = \"Space\";\n  KeyboardCode[\"Down\"] = \"ArrowDown\";\n  KeyboardCode[\"Right\"] = \"ArrowRight\";\n  KeyboardCode[\"Left\"] = \"ArrowLeft\";\n  KeyboardCode[\"Up\"] = \"ArrowUp\";\n  KeyboardCode[\"Esc\"] = \"Escape\";\n  KeyboardCode[\"Enter\"] = \"Enter\";\n})(KeyboardCode || (KeyboardCode = {}));\n// A custom collision detection algorithm is used when using a keyboard to\n// work around an unexpected behavior when reordering items of variable height\n// with the keyboard.\n// Neither closestCenter nor closestCorners work really well for this case,\n// because the center (or corners) of a tall rectangle might be so low that it\n// is detected as being closest to the rectangle below of the one it should\n// actually swap with.\n// Instead of relying on coordinates, the expected results are achieved by\n// moving X positions up or down in the initially sorted array, depending on\n// the desired direction.\n// We let our collisionDetection and customCoordinateGetter use the same\n// getClosestId function which takes its value from the current component\n// state, to make sure they are always in sync.\nexport default function useDragAndDropReorder({\n  items,\n  itemDefinition\n}) {\n  const isKeyboard = useRef(false);\n  const positionDelta = useRef(0);\n  const [activeItemId, setActiveItemId] = useState(null);\n  const setActiveItem = id => {\n    setActiveItemId(id);\n    if (!id) {\n      isKeyboard.current = false;\n      positionDelta.current = 0;\n    }\n  };\n  const handleKeyDown = event => {\n    if (isKeyboard.current && activeItemId) {\n      const currentTargetIndex = items.findIndex(item => itemDefinition.id(item) === activeItemId) + positionDelta.current;\n      if (event.key === 'ArrowDown' && currentTargetIndex < items.length - 1) {\n        positionDelta.current += 1;\n      } else if (event.key === 'ArrowUp' && currentTargetIndex > 0) {\n        positionDelta.current -= 1;\n      }\n    }\n    if (activeItemId && isEscape(event.key)) {\n      // Prevent modal from closing when pressing Esc to cancel the dragging action\n      event.stopPropagation();\n    }\n  };\n  const getClosestId = active => {\n    if (positionDelta.current === 0) {\n      return active.id;\n    }\n    const currentIndex = items.findIndex(item => itemDefinition.id(item) === active.id);\n    const newIndex = Math.max(0, Math.min(items.length - 1, currentIndex + positionDelta.current));\n    return itemDefinition.id(items[newIndex]);\n  };\n  const collisionDetection = ({\n    active,\n    collisionRect,\n    droppableContainers,\n    droppableRects,\n    pointerCoordinates\n  }) => {\n    if (isKeyboard.current) {\n      // For keyboard interaction, determine the colliding container based on the movements made by the arrow keys,\n      // via getClosestId\n      const collidingContainer = getCollidingContainer({\n        activeId: active.id,\n        closestId: getClosestId(active),\n        droppableContainers\n      });\n      return collidingContainer ? [collidingContainer] : [];\n    } else {\n      // For mouse interaction, use the closest center algorithm\n      return closestCenter({\n        active,\n        collisionRect,\n        droppableRects,\n        droppableContainers,\n        pointerCoordinates\n      });\n    }\n  };\n  const coordinateGetter = (event, {\n    context: {\n      active,\n      collisionRect,\n      droppableRects,\n      droppableContainers\n    }\n  }) => {\n    if (event.code === KeyboardCode.Up || event.code === KeyboardCode.Down) {\n      event.preventDefault();\n      if (!active || !collisionRect) {\n        return;\n      }\n      const closestId = getClosestId(active);\n      if (closestId !== null) {\n        const activeDroppable = droppableContainers.get(active.id);\n        const newDroppable = droppableContainers.get(closestId);\n        const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n        const newNode = newDroppable === null || newDroppable === void 0 ? void 0 : newDroppable.node.current;\n        if (newNode && newRect && activeDroppable && newDroppable) {\n          const isAfterActive = isAfter(activeDroppable, newDroppable);\n          const offset = {\n            x: isAfterActive ? collisionRect.width - newRect.width : 0,\n            y: isAfterActive ? collisionRect.height - newRect.height : 0\n          };\n          const rectCoordinates = {\n            x: newRect.left,\n            y: newRect.top\n          };\n          return {\n            x: rectCoordinates.x - offset.x,\n            y: rectCoordinates.y - offset.y\n          };\n        }\n      }\n    }\n  };\n  const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor, {\n    coordinateGetter,\n    onActivation: () => {\n      isKeyboard.current = true;\n    }\n  }));\n  return {\n    activeItemId,\n    setActiveItemId: setActiveItem,\n    collisionDetection,\n    coordinateGetter,\n    handleKeyDown,\n    sensors\n  };\n}\nfunction isAfter(a, b) {\n  return hasSortableData(a) && hasSortableData(b) && a.data.current.sortable.index < b.data.current.sortable.index;\n}\nfunction getCollidingContainer({\n  activeId,\n  closestId,\n  droppableContainers\n}) {\n  if (closestId === activeId) {\n    return;\n  }\n  const collidingContainer = droppableContainers.find(({\n    id\n  }) => id === closestId);\n  if (collidingContainer) {\n    return {\n      id: collidingContainer.id,\n      data: {\n        droppableContainer: collidingContainer,\n        value: 0\n      }\n    };\n  }\n}\nconst isEscape = key => key === 'Escape' || key === 'Esc';","map":{"version":3,"names":["useRef","useState","closestCenter","PointerSensor","useSensor","useSensors","hasSortableData","KeyboardSensor","KeyboardCode","useDragAndDropReorder","items","itemDefinition","isKeyboard","positionDelta","activeItemId","setActiveItemId","setActiveItem","id","current","handleKeyDown","event","currentTargetIndex","findIndex","item","key","length","isEscape","stopPropagation","getClosestId","active","currentIndex","newIndex","Math","max","min","collisionDetection","collisionRect","droppableContainers","droppableRects","pointerCoordinates","collidingContainer","getCollidingContainer","activeId","closestId","coordinateGetter","context","code","Up","Down","preventDefault","activeDroppable","get","newDroppable","newRect","newNode","node","isAfterActive","isAfter","offset","x","width","y","height","rectCoordinates","left","top","sensors","onActivation","a","b","data","sortable","index","find","droppableContainer","value"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/src/internal/components/sortable-area/use-drag-and-drop-reorder.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef, useState } from 'react';\nimport {\n  Active,\n  closestCenter,\n  CollisionDetection,\n  DroppableContainer,\n  KeyboardCoordinateGetter,\n  PointerSensor,\n  UniqueIdentifier,\n  useSensor,\n  useSensors,\n} from '@dnd-kit/core';\nimport { hasSortableData } from '@dnd-kit/sortable';\n\nimport { SortableAreaProps } from './interfaces';\nimport { KeyboardSensor } from './keyboard-sensor';\n\nenum KeyboardCode {\n  Space = 'Space',\n  Down = 'ArrowDown',\n  Right = 'ArrowRight',\n  Left = 'ArrowLeft',\n  Up = 'ArrowUp',\n  Esc = 'Escape',\n  Enter = 'Enter',\n}\n\n// A custom collision detection algorithm is used when using a keyboard to\n// work around an unexpected behavior when reordering items of variable height\n// with the keyboard.\n\n// Neither closestCenter nor closestCorners work really well for this case,\n// because the center (or corners) of a tall rectangle might be so low that it\n// is detected as being closest to the rectangle below of the one it should\n// actually swap with.\n\n// Instead of relying on coordinates, the expected results are achieved by\n// moving X positions up or down in the initially sorted array, depending on\n// the desired direction.\n\n// We let our collisionDetection and customCoordinateGetter use the same\n// getClosestId function which takes its value from the current component\n// state, to make sure they are always in sync.\n\nexport default function useDragAndDropReorder<Item>({\n  items,\n  itemDefinition,\n}: {\n  items: readonly Item[];\n  itemDefinition: SortableAreaProps.ItemDefinition<Item>;\n}) {\n  const isKeyboard = useRef(false);\n  const positionDelta = useRef(0);\n  const [activeItemId, setActiveItemId] = useState<UniqueIdentifier | null>(null);\n\n  const setActiveItem = (id: UniqueIdentifier | null) => {\n    setActiveItemId(id);\n    if (!id) {\n      isKeyboard.current = false;\n      positionDelta.current = 0;\n    }\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    if (isKeyboard.current && activeItemId) {\n      const currentTargetIndex =\n        items.findIndex(item => itemDefinition.id(item) === activeItemId) + positionDelta.current;\n      if (event.key === 'ArrowDown' && currentTargetIndex < items.length - 1) {\n        positionDelta.current += 1;\n      } else if (event.key === 'ArrowUp' && currentTargetIndex > 0) {\n        positionDelta.current -= 1;\n      }\n    }\n    if (activeItemId && isEscape(event.key)) {\n      // Prevent modal from closing when pressing Esc to cancel the dragging action\n      event.stopPropagation();\n    }\n  };\n\n  const getClosestId = (active: Active) => {\n    if (positionDelta.current === 0) {\n      return active.id;\n    }\n    const currentIndex = items.findIndex(item => itemDefinition.id(item) === active.id);\n    const newIndex = Math.max(0, Math.min(items.length - 1, currentIndex + positionDelta.current));\n    return itemDefinition.id(items[newIndex]);\n  };\n\n  const collisionDetection: CollisionDetection = ({\n    active,\n    collisionRect,\n    droppableContainers,\n    droppableRects,\n    pointerCoordinates,\n  }) => {\n    if (isKeyboard.current) {\n      // For keyboard interaction, determine the colliding container based on the movements made by the arrow keys,\n      // via getClosestId\n      const collidingContainer = getCollidingContainer({\n        activeId: active.id,\n        closestId: getClosestId(active),\n        droppableContainers,\n      });\n      return collidingContainer ? [collidingContainer] : [];\n    } else {\n      // For mouse interaction, use the closest center algorithm\n      return closestCenter({ active, collisionRect, droppableRects, droppableContainers, pointerCoordinates });\n    }\n  };\n\n  const coordinateGetter: KeyboardCoordinateGetter = (\n    event,\n    { context: { active, collisionRect, droppableRects, droppableContainers } }\n  ) => {\n    if (event.code === KeyboardCode.Up || event.code === KeyboardCode.Down) {\n      event.preventDefault();\n\n      if (!active || !collisionRect) {\n        return;\n      }\n\n      const closestId = getClosestId(active);\n\n      if (closestId !== null) {\n        const activeDroppable = droppableContainers.get(active.id);\n        const newDroppable = droppableContainers.get(closestId);\n        const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n        const newNode = newDroppable?.node.current;\n\n        if (newNode && newRect && activeDroppable && newDroppable) {\n          const isAfterActive = isAfter(activeDroppable, newDroppable);\n          const offset = {\n            x: isAfterActive ? collisionRect.width - newRect.width : 0,\n            y: isAfterActive ? collisionRect.height - newRect.height : 0,\n          };\n          const rectCoordinates = {\n            x: newRect.left,\n            y: newRect.top,\n          };\n\n          return {\n            x: rectCoordinates.x - offset.x,\n            y: rectCoordinates.y - offset.y,\n          };\n        }\n      }\n    }\n  };\n\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter,\n      onActivation: () => {\n        isKeyboard.current = true;\n      },\n    })\n  );\n\n  return {\n    activeItemId,\n    setActiveItemId: setActiveItem,\n    collisionDetection,\n    coordinateGetter,\n    handleKeyDown,\n    sensors,\n  };\n}\n\nfunction isAfter(a: DroppableContainer, b: DroppableContainer) {\n  return hasSortableData(a) && hasSortableData(b) && a.data.current.sortable.index < b.data.current.sortable.index;\n}\n\nfunction getCollidingContainer({\n  activeId,\n  closestId,\n  droppableContainers,\n}: {\n  activeId: UniqueIdentifier;\n  closestId: UniqueIdentifier;\n  droppableContainers: DroppableContainer[];\n}) {\n  if (closestId === activeId) {\n    return;\n  }\n  const collidingContainer = droppableContainers.find(({ id }) => id === closestId);\n  if (collidingContainer) {\n    return {\n      id: collidingContainer.id,\n      data: {\n        droppableContainer: collidingContainer,\n        value: 0,\n      },\n    };\n  }\n}\n\nconst isEscape = (key: string) => key === 'Escape' || key === 'Esc';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}