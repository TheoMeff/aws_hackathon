{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { createContext, forwardRef, useContext, useImperativeHandle, useLayoutEffect, useRef, useState } from 'react';\nimport nodeBelongs from '../../dom/node-belongs';\nexport const defaultValue = {\n  navigationActive: false,\n  registerFocusable: () => () => {}\n};\n/**\n * Single tab stop navigation context is used together with keyboard navigation that requires a single tab stop.\n * It instructs interactive elements to override tab indices for just a single one to remain user-focusable.\n */\nexport const SingleTabStopNavigationContext = createContext(defaultValue);\nexport function useSingleTabStopNavigation(focusable, options) {\n  var _a;\n  const {\n    navigationActive: contextNavigationActive,\n    registerFocusable\n  } = useContext(SingleTabStopNavigationContext);\n  const [focusTargetActive, setFocusTargetActive] = useState(false);\n  const navigationDisabled = (options === null || options === void 0 ? void 0 : options.tabIndex) && (options === null || options === void 0 ? void 0 : options.tabIndex) < 0;\n  const navigationActive = contextNavigationActive && !navigationDisabled;\n  useLayoutEffect(() => {\n    if (navigationActive && focusable && focusable.current) {\n      const unregister = registerFocusable(focusable.current, isFocusable => setFocusTargetActive(isFocusable));\n      return () => unregister();\n    }\n  });\n  let tabIndex = options === null || options === void 0 ? void 0 : options.tabIndex;\n  if (navigationActive) {\n    tabIndex = !focusTargetActive ? -1 : (_a = options === null || options === void 0 ? void 0 : options.tabIndex) !== null && _a !== void 0 ? _a : 0;\n  }\n  return {\n    navigationActive,\n    tabIndex\n  };\n}\nexport const SingleTabStopNavigationProvider = forwardRef(({\n  navigationActive,\n  children,\n  getNextFocusTarget,\n  isElementSuppressed,\n  onRegisterFocusable,\n  onUnregisterActive\n}, ref) => {\n  // A set of registered focusable elements that can use keyboard navigation.\n  const focusables = useRef(new Set());\n  // A map of registered focusable element handlers to update the respective tab indices.\n  const focusHandlers = useRef(new Map());\n  // A map of focusable element states to avoid issuing unnecessary updates to registered elements.\n  const focusablesState = useRef(new WeakMap());\n  // A reference to the currently focused element.\n  const focusTarget = useRef(null);\n  function onUnregisterFocusable(focusableElement) {\n    const isUnregisteringFocusedNode = nodeBelongs(focusableElement, document.activeElement);\n    if (isUnregisteringFocusedNode) {\n      // Wait for unmounted node to get removed from the DOM.\n      setTimeout(() => onUnregisterActive === null || onUnregisterActive === void 0 ? void 0 : onUnregisterActive(focusableElement), 0);\n    }\n  }\n  // Register a focusable element to allow navigating into it.\n  // The focusable element tabIndex is only set to 0 if the element matches the focus target.\n  function registerFocusable(focusableElement, changeHandler) {\n    focusables.current.add(focusableElement);\n    focusHandlers.current.set(focusableElement, changeHandler);\n    const isFocusable = !!focusablesState.current.get(focusableElement);\n    const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));\n    if (newIsFocusable !== isFocusable) {\n      focusablesState.current.set(focusableElement, newIsFocusable);\n      changeHandler(newIsFocusable);\n    }\n    onRegisterFocusable === null || onRegisterFocusable === void 0 ? void 0 : onRegisterFocusable(focusableElement);\n    return () => unregisterFocusable(focusableElement);\n  }\n  function unregisterFocusable(focusableElement) {\n    focusables.current.delete(focusableElement);\n    focusHandlers.current.delete(focusableElement);\n    onUnregisterFocusable === null || onUnregisterFocusable === void 0 ? void 0 : onUnregisterFocusable(focusableElement);\n  }\n  // Update focus target with next single focusable element and notify all registered focusables of a change.\n  function updateFocusTarget() {\n    var _a;\n    focusTarget.current = getNextFocusTarget();\n    for (const focusableElement of focusables.current) {\n      const isFocusable = (_a = focusablesState.current.get(focusableElement)) !== null && _a !== void 0 ? _a : false;\n      const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));\n      if (newIsFocusable !== isFocusable) {\n        focusablesState.current.set(focusableElement, newIsFocusable);\n        focusHandlers.current.get(focusableElement)(newIsFocusable);\n      }\n    }\n  }\n  function getFocusTarget() {\n    return focusTarget.current;\n  }\n  function isRegistered(element) {\n    return focusables.current.has(element);\n  }\n  useImperativeHandle(ref, () => ({\n    updateFocusTarget,\n    getFocusTarget,\n    isRegistered\n  }));\n  return React.createElement(SingleTabStopNavigationContext.Provider, {\n    value: {\n      navigationActive,\n      registerFocusable\n    }\n  }, children);\n});","map":{"version":3,"names":["React","createContext","forwardRef","useContext","useImperativeHandle","useLayoutEffect","useRef","useState","nodeBelongs","defaultValue","navigationActive","registerFocusable","SingleTabStopNavigationContext","useSingleTabStopNavigation","focusable","options","_a","contextNavigationActive","focusTargetActive","setFocusTargetActive","navigationDisabled","tabIndex","current","unregister","isFocusable","SingleTabStopNavigationProvider","children","getNextFocusTarget","isElementSuppressed","onRegisterFocusable","onUnregisterActive","ref","focusables","Set","focusHandlers","Map","focusablesState","WeakMap","focusTarget","onUnregisterFocusable","focusableElement","isUnregisteringFocusedNode","document","activeElement","setTimeout","changeHandler","add","set","get","newIsFocusable","unregisterFocusable","delete","updateFocusTarget","getFocusTarget","isRegistered","element","has","createElement","Provider","value"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/@cloudscape-design/component-toolkit/internal/single-tab-stop/index.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { createContext, forwardRef, useContext, useImperativeHandle, useLayoutEffect, useRef, useState, } from 'react';\nimport nodeBelongs from '../../dom/node-belongs';\nexport const defaultValue = {\n    navigationActive: false,\n    registerFocusable: () => () => { },\n};\n/**\n * Single tab stop navigation context is used together with keyboard navigation that requires a single tab stop.\n * It instructs interactive elements to override tab indices for just a single one to remain user-focusable.\n */\nexport const SingleTabStopNavigationContext = createContext(defaultValue);\nexport function useSingleTabStopNavigation(focusable, options) {\n    var _a;\n    const { navigationActive: contextNavigationActive, registerFocusable } = useContext(SingleTabStopNavigationContext);\n    const [focusTargetActive, setFocusTargetActive] = useState(false);\n    const navigationDisabled = (options === null || options === void 0 ? void 0 : options.tabIndex) && (options === null || options === void 0 ? void 0 : options.tabIndex) < 0;\n    const navigationActive = contextNavigationActive && !navigationDisabled;\n    useLayoutEffect(() => {\n        if (navigationActive && focusable && focusable.current) {\n            const unregister = registerFocusable(focusable.current, isFocusable => setFocusTargetActive(isFocusable));\n            return () => unregister();\n        }\n    });\n    let tabIndex = options === null || options === void 0 ? void 0 : options.tabIndex;\n    if (navigationActive) {\n        tabIndex = !focusTargetActive ? -1 : (_a = options === null || options === void 0 ? void 0 : options.tabIndex) !== null && _a !== void 0 ? _a : 0;\n    }\n    return { navigationActive, tabIndex };\n}\nexport const SingleTabStopNavigationProvider = forwardRef(({ navigationActive, children, getNextFocusTarget, isElementSuppressed, onRegisterFocusable, onUnregisterActive, }, ref) => {\n    // A set of registered focusable elements that can use keyboard navigation.\n    const focusables = useRef(new Set());\n    // A map of registered focusable element handlers to update the respective tab indices.\n    const focusHandlers = useRef(new Map());\n    // A map of focusable element states to avoid issuing unnecessary updates to registered elements.\n    const focusablesState = useRef(new WeakMap());\n    // A reference to the currently focused element.\n    const focusTarget = useRef(null);\n    function onUnregisterFocusable(focusableElement) {\n        const isUnregisteringFocusedNode = nodeBelongs(focusableElement, document.activeElement);\n        if (isUnregisteringFocusedNode) {\n            // Wait for unmounted node to get removed from the DOM.\n            setTimeout(() => onUnregisterActive === null || onUnregisterActive === void 0 ? void 0 : onUnregisterActive(focusableElement), 0);\n        }\n    }\n    // Register a focusable element to allow navigating into it.\n    // The focusable element tabIndex is only set to 0 if the element matches the focus target.\n    function registerFocusable(focusableElement, changeHandler) {\n        focusables.current.add(focusableElement);\n        focusHandlers.current.set(focusableElement, changeHandler);\n        const isFocusable = !!focusablesState.current.get(focusableElement);\n        const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));\n        if (newIsFocusable !== isFocusable) {\n            focusablesState.current.set(focusableElement, newIsFocusable);\n            changeHandler(newIsFocusable);\n        }\n        onRegisterFocusable === null || onRegisterFocusable === void 0 ? void 0 : onRegisterFocusable(focusableElement);\n        return () => unregisterFocusable(focusableElement);\n    }\n    function unregisterFocusable(focusableElement) {\n        focusables.current.delete(focusableElement);\n        focusHandlers.current.delete(focusableElement);\n        onUnregisterFocusable === null || onUnregisterFocusable === void 0 ? void 0 : onUnregisterFocusable(focusableElement);\n    }\n    // Update focus target with next single focusable element and notify all registered focusables of a change.\n    function updateFocusTarget() {\n        var _a;\n        focusTarget.current = getNextFocusTarget();\n        for (const focusableElement of focusables.current) {\n            const isFocusable = (_a = focusablesState.current.get(focusableElement)) !== null && _a !== void 0 ? _a : false;\n            const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));\n            if (newIsFocusable !== isFocusable) {\n                focusablesState.current.set(focusableElement, newIsFocusable);\n                focusHandlers.current.get(focusableElement)(newIsFocusable);\n            }\n        }\n    }\n    function getFocusTarget() {\n        return focusTarget.current;\n    }\n    function isRegistered(element) {\n        return focusables.current.has(element);\n    }\n    useImperativeHandle(ref, () => ({ updateFocusTarget, getFocusTarget, isRegistered }));\n    return (React.createElement(SingleTabStopNavigationContext.Provider, { value: { navigationActive, registerFocusable } }, children));\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}