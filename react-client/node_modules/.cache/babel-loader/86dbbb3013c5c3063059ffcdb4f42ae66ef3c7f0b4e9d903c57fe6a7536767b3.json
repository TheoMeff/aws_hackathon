{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst map = new WeakMap();\nconst MANUAL_TRIGGER_DELAY = 150;\n/**\n * This function determines whether an element is in the viewport. The callback\n * is batched with other elements that also use this function, in order to improve\n * performance.\n */\nexport function isInViewport(element, callback) {\n  let resolve = value => {\n    resolve = () => {}; // Prevent multiple execution\n    callback(value);\n  };\n  map.set(element, inViewport => resolve(inViewport));\n  observer.observe(element);\n  /*\n     If the IntersectionObserver does not fire in reasonable time (for example\n     in a background page in Chrome), we need to call the callback manually.\n  \n     See https://issues.chromium.org/issues/41383759\n     */\n  const timeoutHandle = setTimeout(() => resolve(false), MANUAL_TRIGGER_DELAY);\n  // Cleanup\n  return () => {\n    clearTimeout(timeoutHandle);\n    map.delete(element);\n    observer.unobserve(element);\n  };\n}\nfunction createIntersectionObserver(callback) {\n  if (typeof IntersectionObserver === 'undefined') {\n    return {\n      observe: () => {},\n      unobserve: () => {}\n    };\n  }\n  return new IntersectionObserver(callback);\n}\nconst observer = createIntersectionObserver(function isInViewportObserver(entries) {\n  var _a;\n  for (const entry of entries) {\n    observer.unobserve(entry.target); // We only want the first run of the observer for each element.\n    (_a = map.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry.isIntersecting);\n    map.delete(entry.target);\n  }\n});","map":{"version":3,"names":["map","WeakMap","MANUAL_TRIGGER_DELAY","isInViewport","element","callback","resolve","value","set","inViewport","observer","observe","timeoutHandle","setTimeout","clearTimeout","delete","unobserve","createIntersectionObserver","IntersectionObserver","isInViewportObserver","entries","entry","target","_a","get","isIntersecting"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/src/internal/hooks/use-performance-marks/is-in-viewport.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\ntype Callback = (inViewport: boolean) => void;\nconst map = new WeakMap<Element, Callback>();\n\nconst MANUAL_TRIGGER_DELAY = 150;\n\n/**\n * This function determines whether an element is in the viewport. The callback\n * is batched with other elements that also use this function, in order to improve\n * performance.\n */\nexport function isInViewport(element: Element, callback: Callback) {\n  let resolve = (value: boolean) => {\n    resolve = () => {}; // Prevent multiple execution\n    callback(value);\n  };\n\n  map.set(element, inViewport => resolve(inViewport));\n  observer.observe(element);\n\n  /*\n\t If the IntersectionObserver does not fire in reasonable time (for example\n\t in a background page in Chrome), we need to call the callback manually.\n  \n\t See https://issues.chromium.org/issues/41383759\n\t */\n  const timeoutHandle = setTimeout(() => resolve(false), MANUAL_TRIGGER_DELAY);\n\n  // Cleanup\n  return () => {\n    clearTimeout(timeoutHandle);\n    map.delete(element);\n    observer.unobserve(element);\n  };\n}\n\nfunction createIntersectionObserver(callback: IntersectionObserverCallback) {\n  if (typeof IntersectionObserver === 'undefined') {\n    return {\n      observe: () => {},\n      unobserve: () => {},\n    };\n  }\n  return new IntersectionObserver(callback);\n}\n\nconst observer = createIntersectionObserver(function isInViewportObserver(entries) {\n  for (const entry of entries) {\n    observer.unobserve(entry.target); // We only want the first run of the observer for each element.\n    map.get(entry.target)?.(entry.isIntersecting);\n    map.delete(entry.target);\n  }\n});\n"],"mappings":"AAAA;AACA;AAGA,MAAMA,GAAG,GAAG,IAAIC,OAAO,EAAqB;AAE5C,MAAMC,oBAAoB,GAAG,GAAG;AAEhC;;;;;AAKA,OAAM,SAAUC,YAAYA,CAACC,OAAgB,EAAEC,QAAkB;EAC/D,IAAIC,OAAO,GAAIC,KAAc,IAAI;IAC/BD,OAAO,GAAGA,CAAA,KAAK,CAAE,CAAC,CAAC,CAAC;IACpBD,QAAQ,CAACE,KAAK,CAAC;EACjB,CAAC;EAEDP,GAAG,CAACQ,GAAG,CAACJ,OAAO,EAAEK,UAAU,IAAIH,OAAO,CAACG,UAAU,CAAC,CAAC;EACnDC,QAAQ,CAACC,OAAO,CAACP,OAAO,CAAC;EAEzB;;;;;;EAMA,MAAMQ,aAAa,GAAGC,UAAU,CAAC,MAAMP,OAAO,CAAC,KAAK,CAAC,EAAEJ,oBAAoB,CAAC;EAE5E;EACA,OAAO,MAAK;IACVY,YAAY,CAACF,aAAa,CAAC;IAC3BZ,GAAG,CAACe,MAAM,CAACX,OAAO,CAAC;IACnBM,QAAQ,CAACM,SAAS,CAACZ,OAAO,CAAC;EAC7B,CAAC;AACH;AAEA,SAASa,0BAA0BA,CAACZ,QAAsC;EACxE,IAAI,OAAOa,oBAAoB,KAAK,WAAW,EAAE;IAC/C,OAAO;MACLP,OAAO,EAAEA,CAAA,KAAK,CAAE,CAAC;MACjBK,SAAS,EAAEA,CAAA,KAAK,CAAE;KACnB;;EAEH,OAAO,IAAIE,oBAAoB,CAACb,QAAQ,CAAC;AAC3C;AAEA,MAAMK,QAAQ,GAAGO,0BAA0B,CAAC,SAASE,oBAAoBA,CAACC,OAAO;;EAC/E,KAAK,MAAMC,KAAK,IAAID,OAAO,EAAE;IAC3BV,QAAQ,CAACM,SAAS,CAACK,KAAK,CAACC,MAAM,CAAC,CAAC,CAAC;IAClC,CAAAC,EAAA,GAAAvB,GAAG,CAACwB,GAAG,CAACH,KAAK,CAACC,MAAM,CAAC,cAAAC,EAAA,uBAAAA,EAAA,CAAGF,KAAK,CAACI,cAAc,CAAC;IAC7CzB,GAAG,CAACe,MAAM,CAACM,KAAK,CAACC,MAAM,CAAC;;AAE5B,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}