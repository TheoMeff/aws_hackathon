{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __rest } from \"tslib\";\nimport React, { useEffect, useImperativeHandle, useRef } from 'react';\nimport clsx from 'clsx';\nimport { useMergeRefs } from '@cloudscape-design/component-toolkit/internal';\nimport { getBaseProps } from '../internal/base-component';\nimport { LiveRegionController } from './controller';\nimport styles from './styles.css.js';\nimport testUtilStyles from './test-classes/styles.css.js';\nexport default React.forwardRef(function InternalLiveRegion(_a, ref) {\n  var {\n      assertive = false,\n      hidden = false,\n      tagName: TagName = 'div',\n      delay,\n      sources,\n      children,\n      __internalRootRef,\n      className\n    } = _a,\n    restProps = __rest(_a, [\"assertive\", \"hidden\", \"tagName\", \"delay\", \"sources\", \"children\", \"__internalRootRef\", \"className\"]);\n  const baseProps = getBaseProps(restProps);\n  const childrenRef = useRef(null);\n  const mergedRef = useMergeRefs(childrenRef, __internalRootRef);\n  useEffect(() => {\n    // We have to do this because `inert` isn't properly supported until\n    // React 19 and this seems much more maintainable than version detection.\n    // `inert` is better than `hidden` because it also blocks pointer and\n    // focus events as well as hiding the contents from screen readers.\n    // https://github.com/facebook/react/issues/17157\n    if (childrenRef.current) {\n      childrenRef.current.inert = hidden;\n    }\n  }, [hidden]);\n  // Initialize the live region controller inside an effect. We have to do this\n  // because the controller depends on DOM elements, which aren't available on the\n  // server.\n  const liveRegionControllerRef = useRef();\n  useEffect(() => {\n    const liveRegionController = new LiveRegionController(assertive ? 'assertive' : 'polite');\n    liveRegionControllerRef.current = liveRegionController;\n    return () => {\n      liveRegionController.destroy();\n      liveRegionControllerRef.current = undefined;\n    };\n  }, [assertive]);\n  const getContent = () => {\n    if (sources) {\n      return getSourceContent(sources);\n    }\n    if (childrenRef.current) {\n      return extractTextContent(childrenRef.current);\n    }\n  };\n  // Call the controller on every render. The controller will deduplicate the\n  // message against the previous announcement internally.\n  useEffect(() => {\n    var _a;\n    (_a = liveRegionControllerRef.current) === null || _a === void 0 ? void 0 : _a.announce({\n      message: getContent(),\n      delay\n    });\n  });\n  useImperativeHandle(ref, () => ({\n    reannounce() {\n      var _a;\n      (_a = liveRegionControllerRef.current) === null || _a === void 0 ? void 0 : _a.announce({\n        message: getContent(),\n        delay,\n        forceReannounce: true\n      });\n    }\n  }));\n  return React.createElement(TagName, Object.assign({\n    ref: mergedRef\n  }, baseProps, {\n    className: clsx(styles.root, testUtilStyles.root, className),\n    hidden: hidden\n  }), children);\n});\nconst processNode = childNode => {\n  if (childNode.nodeType === Node.TEXT_NODE) {\n    return childNode.textContent || '';\n  }\n  if (childNode.nodeType === Node.ELEMENT_NODE) {\n    return extractTextContent(childNode);\n  }\n  return '';\n};\nexport function extractTextContent(node) {\n  var _a;\n  // We use the text content of the node as the announcement text.\n  // This only extracts text content from the node including all its children which is enough for now.\n  // To make it more powerful, it is possible to create a more sophisticated extractor with respect to\n  // ARIA properties to ignore aria-hidden nodes and read ARIA labels from the live content.\n  if (!node || !((_a = node === null || node === void 0 ? void 0 : node.childNodes) === null || _a === void 0 ? void 0 : _a.length)) {\n    return '';\n  }\n  return Array.from(node.childNodes, processNode).join(' ').replace(/\\s+/g, ' ').trim();\n}\nfunction getSourceContent(source) {\n  return source.map(item => {\n    if (!item || typeof item === 'string') {\n      return item;\n    }\n    if (item.current) {\n      return extractTextContent(item.current);\n    }\n  }).filter(Boolean).join(' ');\n}","map":{"version":3,"names":["React","useEffect","useImperativeHandle","useRef","clsx","useMergeRefs","getBaseProps","LiveRegionController","styles","testUtilStyles","forwardRef","InternalLiveRegion","_a","ref","assertive","hidden","tagName","TagName","delay","sources","children","__internalRootRef","className","restProps","__rest","baseProps","childrenRef","mergedRef","current","inert","liveRegionControllerRef","liveRegionController","destroy","undefined","getContent","getSourceContent","extractTextContent","announce","message","reannounce","forceReannounce","createElement","Object","assign","root","processNode","childNode","nodeType","Node","TEXT_NODE","textContent","ELEMENT_NODE","node","childNodes","length","Array","from","join","replace","trim","source","map","item","filter","Boolean"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/src/live-region/internal.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useEffect, useImperativeHandle, useRef } from 'react';\nimport clsx from 'clsx';\n\nimport { useMergeRefs } from '@cloudscape-design/component-toolkit/internal';\n\nimport { getBaseProps } from '../internal/base-component';\nimport { InternalBaseComponentProps } from '../internal/hooks/use-base-component';\nimport { LiveRegionController } from './controller';\nimport { LiveRegionProps } from './interfaces';\n\nimport styles from './styles.css.js';\nimport testUtilStyles from './test-classes/styles.css.js';\n\ninterface InternalLiveRegionProps extends InternalBaseComponentProps, LiveRegionProps {\n  /**\n   * The delay between each announcement from this live region. You should\n   * leave this set to the default unless this live region is commonly\n   * interrupted by other actions (like text entry in text filtering).\n   */\n  delay?: number;\n\n  /**\n   * Use a list of strings and/or refs to existing elements for building the\n   * announcement text. If this property is set, `children` and `message` will\n   * be ignored.\n   */\n  sources?: ReadonlyArray<string | React.RefObject<HTMLElement> | undefined>;\n}\n\nexport interface InternalLiveRegionRef {\n  /**\n   * Force the live region to announce the message, even if it's the same as\n   * the previously announced message.\n   *\n   * This is useful when making status updates after a change (e.g. filtering)\n   * where the new message might be the same as the old one, but the announcement\n   * also serves to tell screen reader users that the action was performed.\n   */\n  reannounce(): void;\n}\n\nexport default React.forwardRef(function InternalLiveRegion(\n  {\n    assertive = false,\n    hidden = false,\n    tagName: TagName = 'div',\n    delay,\n    sources,\n    children,\n    __internalRootRef,\n    className,\n    ...restProps\n  }: InternalLiveRegionProps,\n  ref: React.Ref<InternalLiveRegionRef>\n) {\n  const baseProps = getBaseProps(restProps);\n  const childrenRef = useRef<HTMLSpanElement & HTMLDivElement>(null);\n  const mergedRef = useMergeRefs(childrenRef, __internalRootRef);\n\n  useEffect(() => {\n    // We have to do this because `inert` isn't properly supported until\n    // React 19 and this seems much more maintainable than version detection.\n    // `inert` is better than `hidden` because it also blocks pointer and\n    // focus events as well as hiding the contents from screen readers.\n    // https://github.com/facebook/react/issues/17157\n    if (childrenRef.current) {\n      childrenRef.current.inert = hidden;\n    }\n  }, [hidden]);\n\n  // Initialize the live region controller inside an effect. We have to do this\n  // because the controller depends on DOM elements, which aren't available on the\n  // server.\n  const liveRegionControllerRef = useRef<LiveRegionController | undefined>();\n  useEffect(() => {\n    const liveRegionController = new LiveRegionController(assertive ? 'assertive' : 'polite');\n    liveRegionControllerRef.current = liveRegionController;\n    return () => {\n      liveRegionController.destroy();\n      liveRegionControllerRef.current = undefined;\n    };\n  }, [assertive]);\n\n  const getContent = () => {\n    if (sources) {\n      return getSourceContent(sources);\n    }\n    if (childrenRef.current) {\n      return extractTextContent(childrenRef.current);\n    }\n  };\n\n  // Call the controller on every render. The controller will deduplicate the\n  // message against the previous announcement internally.\n  useEffect(() => {\n    liveRegionControllerRef.current?.announce({ message: getContent(), delay });\n  });\n\n  useImperativeHandle(ref, () => ({\n    reannounce() {\n      liveRegionControllerRef.current?.announce({ message: getContent(), delay, forceReannounce: true });\n    },\n  }));\n\n  return (\n    <TagName\n      ref={mergedRef}\n      {...baseProps}\n      className={clsx(styles.root, testUtilStyles.root, className)}\n      hidden={hidden}\n    >\n      {children}\n    </TagName>\n  );\n});\n\nconst processNode = (childNode: Node): string => {\n  if (childNode.nodeType === Node.TEXT_NODE) {\n    return childNode.textContent || '';\n  }\n\n  if (childNode.nodeType === Node.ELEMENT_NODE) {\n    return extractTextContent(childNode as HTMLElement);\n  }\n\n  return '';\n};\n\nexport function extractTextContent(node: HTMLElement): string {\n  // We use the text content of the node as the announcement text.\n  // This only extracts text content from the node including all its children which is enough for now.\n  // To make it more powerful, it is possible to create a more sophisticated extractor with respect to\n  // ARIA properties to ignore aria-hidden nodes and read ARIA labels from the live content.\n  if (!node || !node?.childNodes?.length) {\n    return '';\n  }\n\n  return Array.from(node.childNodes, processNode).join(' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction getSourceContent(source: ReadonlyArray<string | React.RefObject<HTMLElement> | undefined>): string {\n  return source\n    .map(item => {\n      if (!item || typeof item === 'string') {\n        return item;\n      }\n      if (item.current) {\n        return extractTextContent(item.current);\n      }\n    })\n    .filter(Boolean)\n    .join(' ');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}