{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useState } from 'react';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { useUniqueId } from '../../internal/hooks/use-unique-id';\nimport { joinStrings } from '../../internal/utils/strings';\nimport { getTrackableValue } from '../utils';\nimport { ItemSet } from './utils';\nexport function useSelection(options) {\n  const singleSelectionProps = useSingleSelection(options);\n  const multiSelectionProps = useMultiSelection(options);\n  return options.selectionType === 'single' ? singleSelectionProps : multiSelectionProps;\n}\nfunction useSingleSelection({\n  ariaLabels,\n  isItemDisabled = () => false,\n  onSelectionChange,\n  selectedItems = [],\n  selectionType,\n  trackBy,\n  setLastUserAction\n}) {\n  // The name assigned to all controls to combine them in a single group.\n  const selectionControlName = useUniqueId();\n  if (selectionType !== 'single') {\n    return {\n      isItemSelected: () => false\n    };\n  }\n  // Selection state for individual items.\n  const selectedSet = new ItemSet(trackBy, selectedItems.slice(0, 1));\n  const isItemSelected = selectedSet.has.bind(selectedSet);\n  const handleToggleItem = item => {\n    if (!isItemDisabled(item) && !isItemSelected(item)) {\n      fireNonCancelableEvent(onSelectionChange, {\n        selectedItems: [item]\n      });\n      setLastUserAction === null || setLastUserAction === void 0 ? void 0 : setLastUserAction('selection');\n    }\n  };\n  return {\n    isItemSelected,\n    getItemSelectionProps: item => {\n      var _a;\n      return {\n        name: selectionControlName,\n        selectionType: 'single',\n        disabled: isItemDisabled(item),\n        checked: isItemSelected(item),\n        onChange: () => handleToggleItem(item),\n        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.itemSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, {\n          selectedItems\n        }, item))\n      };\n    }\n  };\n}\nfunction useMultiSelection({\n  ariaLabels,\n  isItemDisabled = () => false,\n  items,\n  loading,\n  onSelectionChange,\n  selectedItems = [],\n  selectionType,\n  trackBy,\n  setLastUserAction\n}) {\n  // The name assigned to all controls to combine them in a single group.\n  const selectionControlName = useUniqueId();\n  const [shiftPressed, setShiftPressed] = useState(false);\n  const [lastClickedItem, setLastClickedItem] = useState(null);\n  if (selectionType !== 'multi') {\n    return {\n      isItemSelected: () => false\n    };\n  }\n  // Selection state for individual items.\n  const selectedSet = new ItemSet(trackBy, selectedItems);\n  const isItemSelected = selectedSet.has.bind(selectedSet);\n  // Derived selection state for all-items checkbox.\n  let allItemsDisabled = true;\n  let allEnabledItemsSelected = true;\n  for (const item of items) {\n    allItemsDisabled = allItemsDisabled && isItemDisabled(item);\n    allEnabledItemsSelected = allEnabledItemsSelected && (isItemSelected(item) || isItemDisabled(item));\n  }\n  const allItemsCheckboxSelected = selectedItems.length > 0 && allEnabledItemsSelected;\n  const allItemsCheckboxIndeterminate = selectedItems.length > 0 && !allEnabledItemsSelected;\n  // Shift-selection helpers.\n  const itemIndexesMap = new Map();\n  items.forEach((item, i) => itemIndexesMap.set(getTrackableValue(trackBy, item), i));\n  const getShiftSelectedItems = item => {\n    const lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : undefined;\n    // We use lastClickedItemIndex to determine if filtering/sorting/pagination\n    // made previously selected item invisible, therefore we reset state for shift-select.\n    if (lastClickedItemIndex !== undefined) {\n      const currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item));\n      const start = Math.min(currentItemIndex, lastClickedItemIndex);\n      const end = Math.max(currentItemIndex, lastClickedItemIndex);\n      return items.slice(start, end + 1);\n    }\n    return [item];\n  };\n  // Select items that are not already selected or disabled.\n  const selectItems = requestedItems => {\n    const newSelectedItems = [...selectedItems];\n    requestedItems.forEach(newItem => {\n      if (!isItemSelected(newItem) && !isItemDisabled(newItem)) {\n        newSelectedItems.push(newItem);\n      }\n    });\n    return newSelectedItems;\n  };\n  // Unselect items unless they are disabled.\n  const deselectItems = requestedItems => {\n    const requestedItemsSet = new ItemSet(trackBy, requestedItems);\n    const newSelectedItems = [];\n    selectedItems.forEach(selectedItem => {\n      const shouldUnselect = requestedItemsSet.has(selectedItem);\n      if (!shouldUnselect || isItemDisabled(selectedItem)) {\n        newSelectedItems.push(selectedItem);\n      }\n    });\n    return newSelectedItems;\n  };\n  const handleToggleAll = () => {\n    const newSelectedItems = allEnabledItemsSelected ? deselectItems(items) : selectItems(items);\n    fireNonCancelableEvent(onSelectionChange, {\n      selectedItems: newSelectedItems\n    });\n    setLastUserAction === null || setLastUserAction === void 0 ? void 0 : setLastUserAction('selection');\n  };\n  const handleToggleItem = item => {\n    if (!isItemDisabled(item)) {\n      const requestedItems = shiftPressed ? getShiftSelectedItems(item) : [item];\n      const selectedItems = isItemSelected(item) ? deselectItems(requestedItems) : selectItems(requestedItems);\n      fireNonCancelableEvent(onSelectionChange, {\n        selectedItems\n      });\n      setLastClickedItem(item);\n      setLastUserAction === null || setLastUserAction === void 0 ? void 0 : setLastUserAction('selection');\n    }\n  };\n  return {\n    isItemSelected,\n    getSelectAllProps: () => {\n      var _a;\n      return {\n        name: selectionControlName,\n        selectionType: 'multi',\n        disabled: allItemsDisabled || !!loading,\n        checked: allItemsCheckboxSelected,\n        indeterminate: allItemsCheckboxIndeterminate,\n        onChange: handleToggleAll,\n        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.allItemsSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, {\n          selectedItems\n        })),\n        selectionGroupLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel\n      };\n    },\n    getItemSelectionProps: item => {\n      var _a;\n      return {\n        name: selectionControlName,\n        selectionType: 'multi',\n        disabled: isItemDisabled(item),\n        checked: isItemSelected(item),\n        onChange: () => handleToggleItem(item),\n        onShiftToggle: value => setShiftPressed(value),\n        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.itemSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, {\n          selectedItems\n        }, item))\n      };\n    }\n  };\n}","map":{"version":3,"names":["useState","fireNonCancelableEvent","useUniqueId","joinStrings","getTrackableValue","ItemSet","useSelection","options","singleSelectionProps","useSingleSelection","multiSelectionProps","useMultiSelection","selectionType","ariaLabels","isItemDisabled","onSelectionChange","selectedItems","trackBy","setLastUserAction","selectionControlName","isItemSelected","selectedSet","slice","has","bind","handleToggleItem","item","getItemSelectionProps","name","disabled","checked","onChange","ariaLabel","selectionGroupLabel","_a","itemSelectionLabel","call","items","loading","shiftPressed","setShiftPressed","lastClickedItem","setLastClickedItem","allItemsDisabled","allEnabledItemsSelected","allItemsCheckboxSelected","length","allItemsCheckboxIndeterminate","itemIndexesMap","Map","forEach","i","set","getShiftSelectedItems","lastClickedItemIndex","get","undefined","currentItemIndex","start","Math","min","end","max","selectItems","requestedItems","newSelectedItems","newItem","push","deselectItems","requestedItemsSet","selectedItem","shouldUnselect","handleToggleAll","getSelectAllProps","indeterminate","allItemsSelectionLabel","onShiftToggle","value"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/src/table/selection/use-selection.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useState } from 'react';\n\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { useUniqueId } from '../../internal/hooks/use-unique-id';\nimport { joinStrings } from '../../internal/utils/strings';\nimport { TableProps } from '../interfaces';\nimport { getTrackableValue } from '../utils';\nimport { SelectionProps } from './interfaces';\nimport { ItemSet } from './utils';\n\ntype SelectionOptions<T> = Pick<\n  TableProps<T>,\n  | 'ariaLabels'\n  | 'isItemDisabled'\n  | 'items'\n  | 'loading'\n  | 'onSelectionChange'\n  | 'selectedItems'\n  | 'selectionType'\n  | 'trackBy'\n> & { setLastUserAction?: (name: string) => void };\n\nexport function useSelection<T>(options: SelectionOptions<T>): {\n  isItemSelected: (item: T) => boolean;\n  getSelectAllProps?: () => SelectionProps;\n  getItemSelectionProps?: (item: T) => SelectionProps;\n  setLastUserAction?: (name: string) => void;\n} {\n  const singleSelectionProps = useSingleSelection(options);\n  const multiSelectionProps = useMultiSelection(options);\n  return options.selectionType === 'single' ? singleSelectionProps : multiSelectionProps;\n}\n\nfunction useSingleSelection<T>({\n  ariaLabels,\n  isItemDisabled = () => false,\n  onSelectionChange,\n  selectedItems = [],\n  selectionType,\n  trackBy,\n  setLastUserAction,\n}: SelectionOptions<T>) {\n  // The name assigned to all controls to combine them in a single group.\n  const selectionControlName = useUniqueId();\n\n  if (selectionType !== 'single') {\n    return { isItemSelected: () => false };\n  }\n\n  // Selection state for individual items.\n  const selectedSet = new ItemSet(trackBy, selectedItems.slice(0, 1));\n  const isItemSelected = selectedSet.has.bind(selectedSet);\n\n  const handleToggleItem = (item: T) => {\n    if (!isItemDisabled(item) && !isItemSelected(item)) {\n      fireNonCancelableEvent(onSelectionChange, { selectedItems: [item] });\n      setLastUserAction?.('selection');\n    }\n  };\n\n  return {\n    isItemSelected,\n    getItemSelectionProps: (item: T): SelectionProps => ({\n      name: selectionControlName,\n      selectionType: 'single',\n      disabled: isItemDisabled(item),\n      checked: isItemSelected(item),\n      onChange: () => handleToggleItem(item),\n      ariaLabel: joinStrings(\n        ariaLabels?.selectionGroupLabel,\n        ariaLabels?.itemSelectionLabel?.({ selectedItems }, item)\n      ),\n    }),\n  };\n}\n\nfunction useMultiSelection<T>({\n  ariaLabels,\n  isItemDisabled = () => false,\n  items,\n  loading,\n  onSelectionChange,\n  selectedItems = [],\n  selectionType,\n  trackBy,\n  setLastUserAction,\n}: SelectionOptions<T>) {\n  // The name assigned to all controls to combine them in a single group.\n  const selectionControlName = useUniqueId();\n  const [shiftPressed, setShiftPressed] = useState(false);\n  const [lastClickedItem, setLastClickedItem] = useState<null | T>(null);\n\n  if (selectionType !== 'multi') {\n    return { isItemSelected: () => false };\n  }\n\n  // Selection state for individual items.\n  const selectedSet = new ItemSet(trackBy, selectedItems);\n  const isItemSelected = selectedSet.has.bind(selectedSet);\n\n  // Derived selection state for all-items checkbox.\n  let allItemsDisabled = true;\n  let allEnabledItemsSelected = true;\n  for (const item of items) {\n    allItemsDisabled = allItemsDisabled && isItemDisabled(item);\n    allEnabledItemsSelected = allEnabledItemsSelected && (isItemSelected(item) || isItemDisabled(item));\n  }\n  const allItemsCheckboxSelected = selectedItems.length > 0 && allEnabledItemsSelected;\n  const allItemsCheckboxIndeterminate = selectedItems.length > 0 && !allEnabledItemsSelected;\n\n  // Shift-selection helpers.\n  const itemIndexesMap = new Map<T, number>();\n  items.forEach((item, i) => itemIndexesMap.set(getTrackableValue(trackBy, item), i));\n  const getShiftSelectedItems = (item: T): T[] => {\n    const lastClickedItemIndex = lastClickedItem\n      ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem))\n      : undefined;\n    // We use lastClickedItemIndex to determine if filtering/sorting/pagination\n    // made previously selected item invisible, therefore we reset state for shift-select.\n    if (lastClickedItemIndex !== undefined) {\n      const currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item))!;\n      const start = Math.min(currentItemIndex, lastClickedItemIndex);\n      const end = Math.max(currentItemIndex, lastClickedItemIndex);\n      return items.slice(start, end + 1);\n    }\n    return [item];\n  };\n\n  // Select items that are not already selected or disabled.\n  const selectItems = (requestedItems: readonly T[]) => {\n    const newSelectedItems = [...selectedItems];\n    requestedItems.forEach(newItem => {\n      if (!isItemSelected(newItem) && !isItemDisabled(newItem)) {\n        newSelectedItems.push(newItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  // Unselect items unless they are disabled.\n  const deselectItems = (requestedItems: readonly T[]) => {\n    const requestedItemsSet = new ItemSet(trackBy, requestedItems);\n    const newSelectedItems: Array<T> = [];\n    selectedItems.forEach(selectedItem => {\n      const shouldUnselect = requestedItemsSet.has(selectedItem);\n      if (!shouldUnselect || isItemDisabled(selectedItem)) {\n        newSelectedItems.push(selectedItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  const handleToggleAll = () => {\n    const newSelectedItems = allEnabledItemsSelected ? deselectItems(items) : selectItems(items);\n    fireNonCancelableEvent(onSelectionChange, { selectedItems: newSelectedItems });\n    setLastUserAction?.('selection');\n  };\n\n  const handleToggleItem = (item: T) => {\n    if (!isItemDisabled(item)) {\n      const requestedItems = shiftPressed ? getShiftSelectedItems(item) : [item];\n      const selectedItems = isItemSelected(item) ? deselectItems(requestedItems) : selectItems(requestedItems);\n      fireNonCancelableEvent(onSelectionChange, { selectedItems });\n      setLastClickedItem(item);\n      setLastUserAction?.('selection');\n    }\n  };\n\n  return {\n    isItemSelected,\n    getSelectAllProps: (): SelectionProps => ({\n      name: selectionControlName,\n      selectionType: 'multi',\n      disabled: allItemsDisabled || !!loading,\n      checked: allItemsCheckboxSelected,\n      indeterminate: allItemsCheckboxIndeterminate,\n      onChange: handleToggleAll,\n      ariaLabel: joinStrings(ariaLabels?.selectionGroupLabel, ariaLabels?.allItemsSelectionLabel?.({ selectedItems })),\n      selectionGroupLabel: ariaLabels?.selectionGroupLabel,\n    }),\n    getItemSelectionProps: (item: T): SelectionProps => ({\n      name: selectionControlName,\n      selectionType: 'multi',\n      disabled: isItemDisabled(item),\n      checked: isItemSelected(item),\n      onChange: () => handleToggleItem(item),\n      onShiftToggle: (value: boolean) => setShiftPressed(value),\n      ariaLabel: joinStrings(\n        ariaLabels?.selectionGroupLabel,\n        ariaLabels?.itemSelectionLabel?.({ selectedItems }, item)\n      ),\n    }),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}