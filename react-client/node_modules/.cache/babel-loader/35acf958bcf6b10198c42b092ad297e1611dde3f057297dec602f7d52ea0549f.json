{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useEffect, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getFirstFocusable } from '../focus-lock/utils';\nimport Tooltip from '../tooltip';\nimport DirectionButton from './direction-button';\nimport PortalOverlay from './portal-overlay';\nimport styles from './styles.css.js';\nexport default function DragHandleWrapper({\n  directions,\n  tooltipText,\n  children,\n  onDirectionClick,\n  triggerMode = 'focus',\n  initialShowButtons = false,\n  hideButtonsOnDrag,\n  clickDragThreshold\n}) {\n  const wrapperRef = useRef(null);\n  const dragHandleRef = useRef(null);\n  const [showTooltip, setShowTooltip] = useState(false);\n  const [showButtons, setShowButtons] = useState(initialShowButtons);\n  const isPointerDown = useRef(false);\n  const initialPointerPosition = useRef();\n  const didPointerDrag = useRef(false);\n  // The tooltip (\"Drag or select to move/resize\") shouldn't show if clicking\n  // on the handle wouldn't do anything.\n  const isDisabled = !directions['block-start'] && !directions['block-end'] && !directions['inline-start'] && !directions['inline-end'];\n  const onWrapperFocusIn = event => {\n    // The drag handle is focused when it's either tabbed to, or the pointer\n    // is pressed on it. We exclude handling the pointer press in this handler,\n    // since it could be the start of a drag event - the pointer stuff is\n    // handled in the \"pointerup\" listener instead. In cases where focus is moved\n    // to the button (by manually calling `.focus()`, the buttons should only appear)\n    // if the action that triggered the focus move was the result of a keypress.\n    if (document.body.dataset.awsuiFocusVisible && !nodeContains(wrapperRef.current, event.relatedTarget)) {\n      setShowTooltip(false);\n      if (triggerMode === 'focus') {\n        setShowButtons(true);\n      }\n    }\n  };\n  const onWrapperFocusOut = event => {\n    // Close the directional buttons when the focus leaves the drag handle.\n    // \"focusout\" is also triggered when the user leaves the current tab, but\n    // since it'll be returned when they switch back anyway, we exclude that\n    // case by checking for `document.hasFocus()`.\n    if (document.hasFocus() && !nodeContains(wrapperRef.current, event.relatedTarget)) {\n      setShowButtons(false);\n    }\n  };\n  useEffect(() => {\n    const controller = new AbortController();\n    // We need to differentiate between a \"click\" and a \"drag\" action.\n    // We can say a \"click\" happens when a \"pointerdown\" is followed by\n    // a \"pointerup\" with no \"pointermove\" between the two.\n    // However, it would be a poor usability experience if a \"click\" isn't\n    // registered because, while pressing my mouse, I moved it by just one\n    // pixel, making it a \"drag\" instead. So we allow the pointer to move by\n    // `clickDragThreshold` pixels before setting `didPointerDrag` to true.\n    document.addEventListener('pointermove', event => {\n      if (isPointerDown.current && initialPointerPosition.current && (event.clientX > initialPointerPosition.current.x + clickDragThreshold || event.clientX < initialPointerPosition.current.x - clickDragThreshold || event.clientY > initialPointerPosition.current.y + clickDragThreshold || event.clientY < initialPointerPosition.current.y - clickDragThreshold)) {\n        didPointerDrag.current = true;\n        hideButtonsOnDrag && setShowButtons(false);\n      }\n    }, {\n      signal: controller.signal\n    });\n    // Shared behavior when a \"pointerdown\" state ends. This is shared so it\n    // can be called for both \"pointercancel\" and \"pointerup\" events.\n    const resetPointerDownState = () => {\n      isPointerDown.current = false;\n      initialPointerPosition.current = undefined;\n    };\n    document.addEventListener('pointercancel', () => {\n      resetPointerDownState();\n    }, {\n      signal: controller.signal\n    });\n    document.addEventListener('pointerup', () => {\n      if (isPointerDown.current && !didPointerDrag.current) {\n        // The cursor didn't move much between \"pointerdown\" and \"pointerup\".\n        // Handle this as a \"click\" instead of a \"drag\".\n        setShowButtons(true);\n      }\n      resetPointerDownState();\n    }, {\n      signal: controller.signal\n    });\n    return () => controller.abort();\n  }, [clickDragThreshold, hideButtonsOnDrag]);\n  const onHandlePointerDown = event => {\n    // Tooltip behavior: the tooltip should appear on hover, but disappear when\n    // the pointer starts dragging (having the tooltip get in the way while\n    // you're trying to drag upwards is annoying). Additionally, the tooltip\n    // shouldn't reappear when dragging ends, but only when the pointer leaves\n    // the drag handle and comes back.\n    isPointerDown.current = true;\n    didPointerDrag.current = false;\n    initialPointerPosition.current = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    setShowTooltip(false);\n  };\n  // Tooltip behavior: the tooltip should stay open when the cursor moves\n  // from the drag handle into the tooltip content itself. This is why the\n  // handler is set on the wrapper for both the drag handle and the tooltip.\n  const onTooltipGroupPointerEnter = () => {\n    if (!isPointerDown.current) {\n      setShowTooltip(true);\n    }\n  };\n  const onTooltipGroupPointerLeave = () => {\n    setShowTooltip(false);\n  };\n  const onDragHandleKeyDown = event => {\n    // For accessibility reasons, pressing escape should always close the floating controls.\n    if (event.key === 'Escape') {\n      setShowButtons(false);\n    } else if (triggerMode === 'keyboard-activate' && (event.key === 'Enter' || event.key === ' ')) {\n      // toggle buttons when Enter or space is pressed in 'keyboard-activate' triggerMode\n      setShowButtons(prevshowButtons => !prevshowButtons);\n    } else if (event.key !== 'Alt' && event.key !== 'Control' && event.key !== 'Meta' && event.key !== 'Shift' && triggerMode !== 'keyboard-activate') {\n      // Pressing any other key will display the focus-visible ring around the\n      // drag handle if it's in focus, so we should also show the buttons now.\n      setShowButtons(true);\n    }\n  };\n  const onInternalDirectionClick = direction => {\n    var _a;\n    // Move focus back to the wrapper on click. This prevents focus from staying\n    // on an aria-hidden control, and allows future keyboard events to be handled\n    // cleanly using the drag handle's own handlers.\n    if (dragHandleRef.current) {\n      (_a = getFirstFocusable(dragHandleRef.current)) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n    onDirectionClick === null || onDirectionClick === void 0 ? void 0 : onDirectionClick(direction);\n  };\n  return React.createElement(\"div\", {\n    className: clsx(styles['drag-handle-wrapper'], showButtons && styles['drag-handle-wrapper-open']),\n    ref: wrapperRef,\n    onFocus: onWrapperFocusIn,\n    onBlur: onWrapperFocusOut\n  }, React.createElement(\"div\", {\n    onPointerEnter: onTooltipGroupPointerEnter,\n    onPointerLeave: onTooltipGroupPointerLeave\n  }, React.createElement(\"div\", {\n    className: styles['drag-handle'],\n    ref: dragHandleRef,\n    onPointerDown: onHandlePointerDown,\n    onKeyDown: onDragHandleKeyDown\n  }, children), !isDisabled && !showButtons && showTooltip && tooltipText && React.createElement(Tooltip, {\n    trackRef: dragHandleRef,\n    value: tooltipText,\n    onDismiss: () => setShowTooltip(false)\n  })), React.createElement(PortalOverlay, {\n    track: dragHandleRef,\n    isDisabled: !showButtons\n  }, directions['block-start'] && React.createElement(DirectionButton, {\n    show: !isDisabled && showButtons,\n    direction: \"block-start\",\n    state: directions['block-start'],\n    onClick: () => onInternalDirectionClick('block-start')\n  }), directions['block-end'] && React.createElement(DirectionButton, {\n    show: !isDisabled && showButtons,\n    direction: \"block-end\",\n    state: directions['block-end'],\n    onClick: () => onInternalDirectionClick('block-end')\n  }), directions['inline-start'] && React.createElement(DirectionButton, {\n    show: !isDisabled && showButtons,\n    direction: \"inline-start\",\n    state: directions['inline-start'],\n    onClick: () => onInternalDirectionClick('inline-start')\n  }), directions['inline-end'] && React.createElement(DirectionButton, {\n    show: !isDisabled && showButtons,\n    direction: \"inline-end\",\n    state: directions['inline-end'],\n    onClick: () => onInternalDirectionClick('inline-end')\n  })));\n}","map":{"version":3,"names":["React","useEffect","useRef","useState","clsx","nodeContains","getFirstFocusable","Tooltip","DirectionButton","PortalOverlay","styles","DragHandleWrapper","directions","tooltipText","children","onDirectionClick","triggerMode","initialShowButtons","hideButtonsOnDrag","clickDragThreshold","wrapperRef","dragHandleRef","showTooltip","setShowTooltip","showButtons","setShowButtons","isPointerDown","initialPointerPosition","didPointerDrag","isDisabled","onWrapperFocusIn","event","document","body","dataset","awsuiFocusVisible","current","relatedTarget","onWrapperFocusOut","hasFocus","controller","AbortController","addEventListener","clientX","x","clientY","y","signal","resetPointerDownState","undefined","abort","onHandlePointerDown","onTooltipGroupPointerEnter","onTooltipGroupPointerLeave","onDragHandleKeyDown","key","prevshowButtons","onInternalDirectionClick","direction","_a","focus","createElement","className","ref","onFocus","onBlur","onPointerEnter","onPointerLeave","onPointerDown","onKeyDown","trackRef","value","onDismiss","track","show","state","onClick"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/src/internal/components/drag-handle-wrapper/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport clsx from 'clsx';\n\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\n\nimport { getFirstFocusable } from '../focus-lock/utils';\nimport Tooltip from '../tooltip';\nimport DirectionButton from './direction-button';\nimport { Direction, DragHandleWrapperProps } from './interfaces';\nimport PortalOverlay from './portal-overlay';\n\nimport styles from './styles.css.js';\n\nexport default function DragHandleWrapper({\n  directions,\n  tooltipText,\n  children,\n  onDirectionClick,\n  triggerMode = 'focus',\n  initialShowButtons = false,\n  hideButtonsOnDrag,\n  clickDragThreshold,\n}: DragHandleWrapperProps) {\n  const wrapperRef = useRef<HTMLDivElement | null>(null);\n  const dragHandleRef = useRef<HTMLDivElement | null>(null);\n  const [showTooltip, setShowTooltip] = useState(false);\n  const [showButtons, setShowButtons] = useState(initialShowButtons);\n\n  const isPointerDown = useRef(false);\n  const initialPointerPosition = useRef<{ x: number; y: number } | undefined>();\n  const didPointerDrag = useRef(false);\n\n  // The tooltip (\"Drag or select to move/resize\") shouldn't show if clicking\n  // on the handle wouldn't do anything.\n  const isDisabled =\n    !directions['block-start'] && !directions['block-end'] && !directions['inline-start'] && !directions['inline-end'];\n\n  const onWrapperFocusIn: React.FocusEventHandler = event => {\n    // The drag handle is focused when it's either tabbed to, or the pointer\n    // is pressed on it. We exclude handling the pointer press in this handler,\n    // since it could be the start of a drag event - the pointer stuff is\n    // handled in the \"pointerup\" listener instead. In cases where focus is moved\n    // to the button (by manually calling `.focus()`, the buttons should only appear)\n    // if the action that triggered the focus move was the result of a keypress.\n    if (document.body.dataset.awsuiFocusVisible && !nodeContains(wrapperRef.current, event.relatedTarget)) {\n      setShowTooltip(false);\n      if (triggerMode === 'focus') {\n        setShowButtons(true);\n      }\n    }\n  };\n\n  const onWrapperFocusOut: React.FocusEventHandler = event => {\n    // Close the directional buttons when the focus leaves the drag handle.\n    // \"focusout\" is also triggered when the user leaves the current tab, but\n    // since it'll be returned when they switch back anyway, we exclude that\n    // case by checking for `document.hasFocus()`.\n    if (document.hasFocus() && !nodeContains(wrapperRef.current, event.relatedTarget)) {\n      setShowButtons(false);\n    }\n  };\n\n  useEffect(() => {\n    const controller = new AbortController();\n\n    // We need to differentiate between a \"click\" and a \"drag\" action.\n    // We can say a \"click\" happens when a \"pointerdown\" is followed by\n    // a \"pointerup\" with no \"pointermove\" between the two.\n    // However, it would be a poor usability experience if a \"click\" isn't\n    // registered because, while pressing my mouse, I moved it by just one\n    // pixel, making it a \"drag\" instead. So we allow the pointer to move by\n    // `clickDragThreshold` pixels before setting `didPointerDrag` to true.\n    document.addEventListener(\n      'pointermove',\n      event => {\n        if (\n          isPointerDown.current &&\n          initialPointerPosition.current &&\n          (event.clientX > initialPointerPosition.current.x + clickDragThreshold ||\n            event.clientX < initialPointerPosition.current.x - clickDragThreshold ||\n            event.clientY > initialPointerPosition.current.y + clickDragThreshold ||\n            event.clientY < initialPointerPosition.current.y - clickDragThreshold)\n        ) {\n          didPointerDrag.current = true;\n          hideButtonsOnDrag && setShowButtons(false);\n        }\n      },\n      { signal: controller.signal }\n    );\n\n    // Shared behavior when a \"pointerdown\" state ends. This is shared so it\n    // can be called for both \"pointercancel\" and \"pointerup\" events.\n    const resetPointerDownState = () => {\n      isPointerDown.current = false;\n      initialPointerPosition.current = undefined;\n    };\n\n    document.addEventListener(\n      'pointercancel',\n      () => {\n        resetPointerDownState();\n      },\n      { signal: controller.signal }\n    );\n\n    document.addEventListener(\n      'pointerup',\n      () => {\n        if (isPointerDown.current && !didPointerDrag.current) {\n          // The cursor didn't move much between \"pointerdown\" and \"pointerup\".\n          // Handle this as a \"click\" instead of a \"drag\".\n          setShowButtons(true);\n        }\n        resetPointerDownState();\n      },\n      { signal: controller.signal }\n    );\n\n    return () => controller.abort();\n  }, [clickDragThreshold, hideButtonsOnDrag]);\n\n  const onHandlePointerDown: React.PointerEventHandler = event => {\n    // Tooltip behavior: the tooltip should appear on hover, but disappear when\n    // the pointer starts dragging (having the tooltip get in the way while\n    // you're trying to drag upwards is annoying). Additionally, the tooltip\n    // shouldn't reappear when dragging ends, but only when the pointer leaves\n    // the drag handle and comes back.\n\n    isPointerDown.current = true;\n    didPointerDrag.current = false;\n    initialPointerPosition.current = { x: event.clientX, y: event.clientY };\n    setShowTooltip(false);\n  };\n\n  // Tooltip behavior: the tooltip should stay open when the cursor moves\n  // from the drag handle into the tooltip content itself. This is why the\n  // handler is set on the wrapper for both the drag handle and the tooltip.\n  const onTooltipGroupPointerEnter: React.PointerEventHandler = () => {\n    if (!isPointerDown.current) {\n      setShowTooltip(true);\n    }\n  };\n  const onTooltipGroupPointerLeave: React.PointerEventHandler = () => {\n    setShowTooltip(false);\n  };\n\n  const onDragHandleKeyDown: React.KeyboardEventHandler = event => {\n    // For accessibility reasons, pressing escape should always close the floating controls.\n    if (event.key === 'Escape') {\n      setShowButtons(false);\n    } else if (triggerMode === 'keyboard-activate' && (event.key === 'Enter' || event.key === ' ')) {\n      // toggle buttons when Enter or space is pressed in 'keyboard-activate' triggerMode\n      setShowButtons(prevshowButtons => !prevshowButtons);\n    } else if (\n      event.key !== 'Alt' &&\n      event.key !== 'Control' &&\n      event.key !== 'Meta' &&\n      event.key !== 'Shift' &&\n      triggerMode !== 'keyboard-activate'\n    ) {\n      // Pressing any other key will display the focus-visible ring around the\n      // drag handle if it's in focus, so we should also show the buttons now.\n      setShowButtons(true);\n    }\n  };\n\n  const onInternalDirectionClick = (direction: Direction) => {\n    // Move focus back to the wrapper on click. This prevents focus from staying\n    // on an aria-hidden control, and allows future keyboard events to be handled\n    // cleanly using the drag handle's own handlers.\n    if (dragHandleRef.current) {\n      getFirstFocusable(dragHandleRef.current)?.focus();\n    }\n    onDirectionClick?.(direction);\n  };\n\n  return (\n    <div\n      className={clsx(styles['drag-handle-wrapper'], showButtons && styles['drag-handle-wrapper-open'])}\n      ref={wrapperRef}\n      onFocus={onWrapperFocusIn}\n      onBlur={onWrapperFocusOut}\n    >\n      <div onPointerEnter={onTooltipGroupPointerEnter} onPointerLeave={onTooltipGroupPointerLeave}>\n        <div\n          className={styles['drag-handle']}\n          ref={dragHandleRef}\n          onPointerDown={onHandlePointerDown}\n          onKeyDown={onDragHandleKeyDown}\n        >\n          {children}\n        </div>\n\n        {!isDisabled && !showButtons && showTooltip && tooltipText && (\n          <Tooltip trackRef={dragHandleRef} value={tooltipText} onDismiss={() => setShowTooltip(false)} />\n        )}\n      </div>\n\n      <PortalOverlay track={dragHandleRef} isDisabled={!showButtons}>\n        {directions['block-start'] && (\n          <DirectionButton\n            show={!isDisabled && showButtons}\n            direction=\"block-start\"\n            state={directions['block-start']}\n            onClick={() => onInternalDirectionClick('block-start')}\n          />\n        )}\n        {directions['block-end'] && (\n          <DirectionButton\n            show={!isDisabled && showButtons}\n            direction=\"block-end\"\n            state={directions['block-end']}\n            onClick={() => onInternalDirectionClick('block-end')}\n          />\n        )}\n        {directions['inline-start'] && (\n          <DirectionButton\n            show={!isDisabled && showButtons}\n            direction=\"inline-start\"\n            state={directions['inline-start']}\n            onClick={() => onInternalDirectionClick('inline-start')}\n          />\n        )}\n        {directions['inline-end'] && (\n          <DirectionButton\n            show={!isDisabled && showButtons}\n            direction=\"inline-end\"\n            state={directions['inline-end']}\n            onClick={() => onInternalDirectionClick('inline-end')}\n          />\n        )}\n      </PortalOverlay>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}