{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useRef, useState } from 'react';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\nimport { findUpUntilMultiple, isContainingBlock } from '../internal/utils/dom';\nimport { calculateScroll, getFirstScrollableParent, scrollRectangleIntoView } from '../internal/utils/scrollable-containers';\nimport { calculatePosition, getDimensions, getOffsetDimensions, isCenterOutside } from './utils/positions';\nexport default function usePopoverPosition({\n  popoverRef,\n  bodyRef,\n  arrowRef,\n  getTrack,\n  contentRef,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  preferredPosition,\n  renderWithPortal,\n  keepPosition,\n  hideOnOverscroll,\n  minVisibleBlockSize\n}) {\n  const previousInternalPositionRef = useRef(null);\n  const [popoverStyle, setPopoverStyle] = useState({});\n  const [internalPosition, setInternalPosition] = useState(null);\n  const [isOverscrolling, setIsOverscrolling] = useState(false);\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef(() => {});\n  const scrollableContainerRectRef = useRef(null);\n  const updatePositionHandler = useCallback((onContentResize = false) => {\n    var _a;\n    const track = getTrack();\n    if (!track || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n      return;\n    }\n    // Get important elements\n    const popover = popoverRef.current;\n    const body = bodyRef.current;\n    const arrow = arrowRef.current;\n    const document = popover.ownerDocument;\n    // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n    // or track does not belong to the document - bail on calculating dimensions.\n    const {\n      offsetWidth,\n      offsetHeight\n    } = getOffsetDimensions(popover);\n    if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n      return;\n    }\n    // Imperatively move body off-screen to give it room to expand.\n    // Not doing this in React because this recalculation should happen\n    // in the span of a single frame without rerendering anything.\n    const prevInsetBlockStart = popover.style.insetBlockStart;\n    const prevInsetInlineStart = popover.style.insetInlineStart;\n    popover.style.insetBlockStart = '0';\n    popover.style.insetInlineStart = '0';\n    // Imperatively remove body styles that can remain from the previous computation.\n    body.style.maxBlockSize = '';\n    body.style.overflowX = '';\n    body.style.overflowY = '';\n    // Get rects representing key elements\n    // Use getComputedStyle for arrowRect to avoid modifications made by transform\n    const viewportRect = getViewportRect(document.defaultView);\n    const trackRect = getLogicalBoundingClientRect(track);\n    const arrowRect = getDimensions(arrow);\n    const {\n      containingBlock,\n      boundary\n    } = findUpUntilMultiple({\n      startElement: popover,\n      tests: {\n        containingBlock: isContainingBlock,\n        boundary: element => isContainingBlock(element) || isBoundary(element)\n      }\n    });\n    // Rectangle for the containing block, which provides the reference frame for the popover coordinates.\n    const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;\n    // Rectangle outside of which the popover should not be positioned, because it would be clipped.\n    const boundaryRect = boundary ? getLogicalBoundingClientRect(boundary) : getDocumentRect(document);\n    const bodyBorderWidth = getBorderWidth(body);\n    const contentRect = getLogicalBoundingClientRect(contentRef.current);\n    const contentBoundingBox = {\n      inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,\n      blockSize: contentRect.blockSize + 2 * bodyBorderWidth\n    };\n    // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n    // we maintain the previously defined internal position,\n    // but we still call calculatePosition to know if the popover should be scrollable.\n    const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n    const fixedInternalPosition = (_a = shouldKeepPosition && previousInternalPositionRef.current) !== null && _a !== void 0 ? _a : undefined;\n    // Calculate the arrow direction and viewport-relative position of the popover.\n    const {\n      scrollable,\n      internalPosition: newInternalPosition,\n      rect\n    } = calculatePosition({\n      preferredPosition,\n      fixedInternalPosition,\n      trigger: trackRect,\n      arrow: arrowRect,\n      body: contentBoundingBox,\n      container: boundaryRect,\n      viewport: viewportRect,\n      renderWithPortal,\n      allowVerticalOverflow,\n      minVisibleBlockSize\n    });\n    // Get the position of the popover relative to the containing block.\n    const popoverOffset = toRelativePosition(rect, containingBlockRect);\n    // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n    // and use that to recalculate the new popover position.\n    const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n    // Bring back the container to its original position to prevent any flashing.\n    popover.style.insetBlockStart = prevInsetBlockStart;\n    popover.style.insetInlineStart = prevInsetInlineStart;\n    // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n    if (scrollable) {\n      body.style.maxBlockSize = rect.blockSize + 'px';\n      body.style.overflowX = 'hidden';\n      body.style.overflowY = 'auto';\n    }\n    // Remember the internal position in case we want to keep it later.\n    previousInternalPositionRef.current = newInternalPosition;\n    setInternalPosition(newInternalPosition);\n    const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n    // Position the popover\n    const insetBlockStart = shouldScroll ? popoverOffset.insetBlockStart + calculateScroll(rect) : popoverOffset.insetBlockStart;\n    setPopoverStyle({\n      insetBlockStart,\n      insetInlineStart: popoverOffset.insetInlineStart\n    });\n    // Scroll if necessary\n    if (shouldScroll) {\n      const scrollableParent = getFirstScrollableParent(popover);\n      scrollRectangleIntoView(rect, scrollableParent);\n    }\n    if (hideOnOverscroll && track instanceof HTMLElement) {\n      const scrollableContainer = getFirstScrollableParent(track);\n      if (scrollableContainer) {\n        scrollableContainerRectRef.current = getLogicalBoundingClientRect(scrollableContainer);\n      }\n    }\n    positionHandlerRef.current = () => {\n      const track = getTrack();\n      if (!track) {\n        return;\n      }\n      const trackRect = getLogicalBoundingClientRect(track);\n      const newTrackOffset = toRelativePosition(trackRect, containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect);\n      setPopoverStyle({\n        insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,\n        insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart\n      });\n      if (hideOnOverscroll && scrollableContainerRectRef.current) {\n        // Assuming the arrow tip is at the vertical center of the popover trigger.\n        // This is good enough for disabled reason tooltip in select and multiselect.\n        // Can be further refined to take the exact arrow position into account if hideOnOverscroll is to be used in other cases.\n        setIsOverscrolling(isCenterOutside(trackRect, scrollableContainerRectRef.current));\n      }\n    };\n  }, [getTrack, popoverRef, bodyRef, contentRef, arrowRef, keepPosition, preferredPosition, renderWithPortal, allowVerticalOverflow, allowScrollToFit, hideOnOverscroll, minVisibleBlockSize]);\n  return {\n    updatePositionHandler,\n    popoverStyle,\n    internalPosition,\n    positionHandlerRef,\n    isOverscrolling\n  };\n}\nfunction getBorderWidth(element) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element, parent) {\n  return {\n    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,\n    insetInlineStart: element.insetInlineStart - parent.insetInlineStart\n  };\n}\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window) {\n  var _a, _b, _c, _d;\n  return {\n    insetBlockStart: 0,\n    insetInlineStart: 0,\n    inlineSize: (_b = (_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : window.innerWidth,\n    blockSize: (_d = (_c = window.visualViewport) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : window.innerHeight\n  };\n}\nfunction getDocumentRect(document) {\n  const {\n    insetBlockStart,\n    insetInlineStart\n  } = getLogicalBoundingClientRect(document.documentElement);\n  return {\n    insetBlockStart,\n    insetInlineStart,\n    inlineSize: document.documentElement.scrollWidth,\n    blockSize: document.documentElement.scrollHeight\n  };\n}\nfunction isBoundary(element) {\n  const computedStyle = getComputedStyle(element);\n  return !!computedStyle.clipPath && computedStyle.clipPath !== 'none';\n}","map":{"version":3,"names":["useCallback","useRef","useState","nodeContains","getLogicalBoundingClientRect","findUpUntilMultiple","isContainingBlock","calculateScroll","getFirstScrollableParent","scrollRectangleIntoView","calculatePosition","getDimensions","getOffsetDimensions","isCenterOutside","usePopoverPosition","popoverRef","bodyRef","arrowRef","getTrack","contentRef","allowScrollToFit","allowVerticalOverflow","preferredPosition","renderWithPortal","keepPosition","hideOnOverscroll","minVisibleBlockSize","previousInternalPositionRef","popoverStyle","setPopoverStyle","internalPosition","setInternalPosition","isOverscrolling","setIsOverscrolling","positionHandlerRef","scrollableContainerRectRef","updatePositionHandler","onContentResize","track","current","popover","body","arrow","document","ownerDocument","offsetWidth","offsetHeight","prevInsetBlockStart","style","insetBlockStart","prevInsetInlineStart","insetInlineStart","maxBlockSize","overflowX","overflowY","viewportRect","getViewportRect","defaultView","trackRect","arrowRect","containingBlock","boundary","startElement","tests","element","isBoundary","containingBlockRect","boundaryRect","getDocumentRect","bodyBorderWidth","getBorderWidth","contentRect","contentBoundingBox","inlineSize","blockSize","shouldKeepPosition","fixedInternalPosition","_a","undefined","scrollable","newInternalPosition","rect","trigger","container","viewport","popoverOffset","toRelativePosition","trackRelativeOffset","shouldScroll","scrollableParent","HTMLElement","scrollableContainer","newTrackOffset","parseInt","getComputedStyle","borderWidth","parent","window","_b","visualViewport","width","innerWidth","_d","_c","height","innerHeight","documentElement","scrollWidth","scrollHeight","computedStyle","clipPath"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/src/popover/use-popover-position.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useRef, useState } from 'react';\n\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\n\nimport { findUpUntilMultiple, isContainingBlock } from '../internal/utils/dom';\nimport {\n  calculateScroll,\n  getFirstScrollableParent,\n  scrollRectangleIntoView,\n} from '../internal/utils/scrollable-containers';\nimport { BoundingBox, InternalPosition, Offset, PopoverProps, Rect } from './interfaces';\nimport { calculatePosition, getDimensions, getOffsetDimensions, isCenterOutside } from './utils/positions';\n\nexport default function usePopoverPosition({\n  popoverRef,\n  bodyRef,\n  arrowRef,\n  getTrack,\n  contentRef,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  preferredPosition,\n  renderWithPortal,\n  keepPosition,\n  hideOnOverscroll,\n  minVisibleBlockSize,\n}: {\n  popoverRef: React.RefObject<HTMLDivElement | null>;\n  bodyRef: React.RefObject<HTMLDivElement | null>;\n  arrowRef: React.RefObject<HTMLDivElement | null>;\n  getTrack: () => null | HTMLElement | SVGElement;\n  contentRef: React.RefObject<HTMLDivElement | null>;\n  allowScrollToFit?: boolean;\n  allowVerticalOverflow?: boolean;\n  preferredPosition: PopoverProps.Position;\n  renderWithPortal?: boolean;\n  keepPosition?: boolean;\n  hideOnOverscroll?: boolean;\n  minVisibleBlockSize?: number;\n}) {\n  const previousInternalPositionRef = useRef<InternalPosition | null>(null);\n  const [popoverStyle, setPopoverStyle] = useState<Partial<Offset>>({});\n  const [internalPosition, setInternalPosition] = useState<InternalPosition | null>(null);\n  const [isOverscrolling, setIsOverscrolling] = useState(false);\n\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef<() => void>(() => {});\n\n  const scrollableContainerRectRef = useRef<Rect | null>(null);\n\n  const updatePositionHandler = useCallback(\n    (onContentResize = false) => {\n      const track = getTrack();\n      if (!track || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n        return;\n      }\n\n      // Get important elements\n      const popover = popoverRef.current;\n      const body = bodyRef.current;\n      const arrow = arrowRef.current;\n      const document = popover.ownerDocument;\n\n      // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n      // or track does not belong to the document - bail on calculating dimensions.\n      const { offsetWidth, offsetHeight } = getOffsetDimensions(popover);\n      if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n        return;\n      }\n\n      // Imperatively move body off-screen to give it room to expand.\n      // Not doing this in React because this recalculation should happen\n      // in the span of a single frame without rerendering anything.\n      const prevInsetBlockStart = popover.style.insetBlockStart;\n      const prevInsetInlineStart = popover.style.insetInlineStart;\n\n      popover.style.insetBlockStart = '0';\n      popover.style.insetInlineStart = '0';\n      // Imperatively remove body styles that can remain from the previous computation.\n      body.style.maxBlockSize = '';\n      body.style.overflowX = '';\n      body.style.overflowY = '';\n\n      // Get rects representing key elements\n      // Use getComputedStyle for arrowRect to avoid modifications made by transform\n      const viewportRect = getViewportRect(document.defaultView!);\n      const trackRect = getLogicalBoundingClientRect(track);\n      const arrowRect = getDimensions(arrow);\n      const { containingBlock, boundary } = findUpUntilMultiple({\n        startElement: popover,\n        tests: {\n          containingBlock: isContainingBlock,\n          boundary: (element: HTMLElement) => isContainingBlock(element) || isBoundary(element),\n        },\n      });\n\n      // Rectangle for the containing block, which provides the reference frame for the popover coordinates.\n      const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;\n\n      // Rectangle outside of which the popover should not be positioned, because it would be clipped.\n      const boundaryRect = boundary ? getLogicalBoundingClientRect(boundary) : getDocumentRect(document);\n\n      const bodyBorderWidth = getBorderWidth(body);\n      const contentRect = getLogicalBoundingClientRect(contentRef.current);\n      const contentBoundingBox = {\n        inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,\n        blockSize: contentRect.blockSize + 2 * bodyBorderWidth,\n      };\n\n      // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n      // we maintain the previously defined internal position,\n      // but we still call calculatePosition to know if the popover should be scrollable.\n      const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n      const fixedInternalPosition = (shouldKeepPosition && previousInternalPositionRef.current) ?? undefined;\n\n      // Calculate the arrow direction and viewport-relative position of the popover.\n      const {\n        scrollable,\n        internalPosition: newInternalPosition,\n        rect,\n      } = calculatePosition({\n        preferredPosition,\n        fixedInternalPosition,\n        trigger: trackRect,\n        arrow: arrowRect,\n        body: contentBoundingBox,\n        container: boundaryRect,\n        viewport: viewportRect,\n        renderWithPortal,\n        allowVerticalOverflow,\n        minVisibleBlockSize,\n      });\n\n      // Get the position of the popover relative to the containing block.\n      const popoverOffset = toRelativePosition(rect, containingBlockRect);\n\n      // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n      // and use that to recalculate the new popover position.\n      const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n\n      // Bring back the container to its original position to prevent any flashing.\n      popover.style.insetBlockStart = prevInsetBlockStart;\n      popover.style.insetInlineStart = prevInsetInlineStart;\n\n      // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n      if (scrollable) {\n        body.style.maxBlockSize = rect.blockSize + 'px';\n        body.style.overflowX = 'hidden';\n        body.style.overflowY = 'auto';\n      }\n\n      // Remember the internal position in case we want to keep it later.\n      previousInternalPositionRef.current = newInternalPosition;\n      setInternalPosition(newInternalPosition);\n\n      const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n\n      // Position the popover\n      const insetBlockStart = shouldScroll\n        ? popoverOffset.insetBlockStart + calculateScroll(rect)\n        : popoverOffset.insetBlockStart;\n      setPopoverStyle({ insetBlockStart, insetInlineStart: popoverOffset.insetInlineStart });\n\n      // Scroll if necessary\n      if (shouldScroll) {\n        const scrollableParent = getFirstScrollableParent(popover);\n        scrollRectangleIntoView(rect, scrollableParent);\n      }\n\n      if (hideOnOverscroll && track instanceof HTMLElement) {\n        const scrollableContainer = getFirstScrollableParent(track);\n        if (scrollableContainer) {\n          scrollableContainerRectRef.current = getLogicalBoundingClientRect(scrollableContainer);\n        }\n      }\n\n      positionHandlerRef.current = () => {\n        const track = getTrack();\n        if (!track) {\n          return;\n        }\n        const trackRect = getLogicalBoundingClientRect(track);\n\n        const newTrackOffset = toRelativePosition(\n          trackRect,\n          containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect\n        );\n\n        setPopoverStyle({\n          insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,\n          insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart,\n        });\n\n        if (hideOnOverscroll && scrollableContainerRectRef.current) {\n          // Assuming the arrow tip is at the vertical center of the popover trigger.\n          // This is good enough for disabled reason tooltip in select and multiselect.\n          // Can be further refined to take the exact arrow position into account if hideOnOverscroll is to be used in other cases.\n          setIsOverscrolling(isCenterOutside(trackRect, scrollableContainerRectRef.current));\n        }\n      };\n    },\n    [\n      getTrack,\n      popoverRef,\n      bodyRef,\n      contentRef,\n      arrowRef,\n      keepPosition,\n      preferredPosition,\n      renderWithPortal,\n      allowVerticalOverflow,\n      allowScrollToFit,\n      hideOnOverscroll,\n      minVisibleBlockSize,\n    ]\n  );\n  return { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef, isOverscrolling };\n}\n\nfunction getBorderWidth(element: HTMLElement) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element: Offset, parent: Offset): Offset {\n  return {\n    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,\n    insetInlineStart: element.insetInlineStart - parent.insetInlineStart,\n  };\n}\n\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window: Window): BoundingBox {\n  return {\n    insetBlockStart: 0,\n    insetInlineStart: 0,\n    inlineSize: window.visualViewport?.width ?? window.innerWidth,\n    blockSize: window.visualViewport?.height ?? window.innerHeight,\n  };\n}\n\nfunction getDocumentRect(document: Document): BoundingBox {\n  const { insetBlockStart, insetInlineStart } = getLogicalBoundingClientRect(document.documentElement);\n\n  return {\n    insetBlockStart,\n    insetInlineStart,\n    inlineSize: document.documentElement.scrollWidth,\n    blockSize: document.documentElement.scrollHeight,\n  };\n}\n\nfunction isBoundary(element: HTMLElement) {\n  const computedStyle = getComputedStyle(element);\n  return !!computedStyle.clipPath && computedStyle.clipPath !== 'none';\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}