{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport balanced from 'balanced-match';\nimport { findUpUntil } from '@cloudscape-design/component-toolkit/dom';\nexport function isContainingBlock(element) {\n  var _a;\n  const computedStyle = getComputedStyle(element);\n  return !!computedStyle.transform && computedStyle.transform !== 'none' || !!computedStyle.perspective && computedStyle.perspective !== 'none' || ((_a = computedStyle.contain) === null || _a === void 0 ? void 0 : _a.split(' ').some(s => ['layout', 'paint', 'strict', 'content'].includes(s)));\n}\n/**\n * Returns an element that is used to position the given element.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block\n */\nexport function getContainingBlock(startElement) {\n  if (!startElement.parentElement) {\n    return null;\n  }\n  return findUpUntil(startElement.parentElement, isContainingBlock);\n}\n/*\n * Allows to find multiple elements in the page each according to a specific test function,\n * but traversing the DOM only once.\n */\nexport function findUpUntilMultiple({\n  startElement,\n  tests\n}) {\n  const keys = Object.keys(tests);\n  const elements = {};\n  let current = startElement;\n  while (current && Object.keys(elements).length < keys.length) {\n    current = current.parentElement;\n    // If a component is used within an svg (i.e. as foreignObject), then it will\n    // have some ancestor nodes that are SVGElement. We want to skip those,\n    // as they have very different properties to HTMLElements.\n    while (current && !isHTMLElement(current)) {\n      current = current.parentElement;\n    }\n    for (const key of keys) {\n      if (!elements[key] && current && tests[key](current)) {\n        elements[key] = current;\n      }\n    }\n  }\n  return elements;\n}\nconst cssVariableExpression = /--.+?\\s*,\\s*(.+)/;\n/**\n * Parses a CSS color value that might contain CSS Custom Properties\n * and returns a value that will be understood by the browser, no matter of support level.\n * If the browser support CSS Custom Properties, the value will be return as is. Otherwise,\n * the fallback value will be extracted and returned instead.\n */\nexport function parseCssVariable(value) {\n  var _a, _b, _c;\n  if (typeof window === 'undefined') {\n    return value;\n  }\n  if ((_c = (_b = (_a = window.CSS) === null || _a === void 0 ? void 0 : _a.supports) === null || _b === void 0 ? void 0 : _b.call(_a, 'color', 'var(--dummy, #000)')) !== null && _c !== void 0 ? _c : false) {\n    return value;\n  }\n  const varIndex = value.lastIndexOf('var(');\n  if (varIndex === -1) {\n    return value;\n  }\n  const expr = balanced('(', ')', value.substr(varIndex));\n  if (!expr) {\n    return value;\n  }\n  const match = expr.body.match(cssVariableExpression);\n  return match ? match[1] : value;\n}\n// The instanceof Node/HTMLElement/SVGElement checks can fail if the target element\n// belongs to a different window than the respective type.\nexport function isNode(target) {\n  return target instanceof Node || target !== null && typeof target === 'object' && 'nodeType' in target && typeof target.nodeType === 'number' && 'nodeName' in target && typeof target.nodeName === 'string' && 'parentNode' in target && typeof target.parentNode === 'object';\n}\nexport function isHTMLElement(target) {\n  return target instanceof HTMLElement || isNode(target) && target.nodeType === Node.ELEMENT_NODE && 'style' in target && typeof target.style === 'object' && typeof target.ownerDocument === 'object' && !isSVGElement(target);\n}\nexport function isSVGElement(target) {\n  return target instanceof SVGElement || isNode(target) && target.nodeType === Node.ELEMENT_NODE && 'ownerSVGElement' in target && typeof target.ownerSVGElement === 'object';\n}","map":{"version":3,"names":["balanced","findUpUntil","isContainingBlock","element","computedStyle","getComputedStyle","transform","perspective","_a","contain","split","some","s","includes","getContainingBlock","startElement","parentElement","findUpUntilMultiple","tests","keys","Object","elements","current","length","isHTMLElement","key","cssVariableExpression","parseCssVariable","value","window","_c","_b","CSS","supports","call","varIndex","lastIndexOf","expr","substr","match","body","isNode","target","Node","nodeType","nodeName","parentNode","HTMLElement","ELEMENT_NODE","style","ownerDocument","isSVGElement","SVGElement","ownerSVGElement"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/node_modules/src/internal/utils/dom.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport balanced from 'balanced-match';\n\nimport { findUpUntil } from '@cloudscape-design/component-toolkit/dom';\n\nexport function isContainingBlock(element: HTMLElement): boolean {\n  const computedStyle = getComputedStyle(element);\n  return (\n    (!!computedStyle.transform && computedStyle.transform !== 'none') ||\n    (!!computedStyle.perspective && computedStyle.perspective !== 'none') ||\n    computedStyle.contain?.split(' ').some(s => ['layout', 'paint', 'strict', 'content'].includes(s))\n  );\n}\n\n/**\n * Returns an element that is used to position the given element.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block\n */\nexport function getContainingBlock(startElement: HTMLElement): HTMLElement | null {\n  if (!startElement.parentElement) {\n    return null;\n  }\n\n  return findUpUntil(startElement.parentElement, isContainingBlock) as HTMLElement;\n}\n\n/*\n * Allows to find multiple elements in the page each according to a specific test function,\n * but traversing the DOM only once.\n */\n\nexport function findUpUntilMultiple({\n  startElement,\n  tests,\n}: {\n  startElement: HTMLElement;\n  tests: Record<string, (el: HTMLElement) => boolean>;\n}) {\n  const keys = Object.keys(tests);\n  const elements: Record<string, HTMLElement> = {};\n  let current: HTMLElement | null = startElement;\n  while (current && Object.keys(elements).length < keys.length) {\n    current = current.parentElement;\n    // If a component is used within an svg (i.e. as foreignObject), then it will\n    // have some ancestor nodes that are SVGElement. We want to skip those,\n    // as they have very different properties to HTMLElements.\n    while (current && !isHTMLElement(current)) {\n      current = (current as Element).parentElement;\n    }\n    for (const key of keys) {\n      if (!elements[key] && current && tests[key](current)) {\n        elements[key] = current;\n      }\n    }\n  }\n  return elements;\n}\n\nconst cssVariableExpression = /--.+?\\s*,\\s*(.+)/;\n\n/**\n * Parses a CSS color value that might contain CSS Custom Properties\n * and returns a value that will be understood by the browser, no matter of support level.\n * If the browser support CSS Custom Properties, the value will be return as is. Otherwise,\n * the fallback value will be extracted and returned instead.\n */\nexport function parseCssVariable(value: string) {\n  if (typeof window === 'undefined') {\n    return value;\n  }\n\n  if (window.CSS?.supports?.('color', 'var(--dummy, #000)') ?? false) {\n    return value;\n  }\n\n  const varIndex = value.lastIndexOf('var(');\n  if (varIndex === -1) {\n    return value;\n  }\n\n  const expr = balanced('(', ')', value.substr(varIndex));\n  if (!expr) {\n    return value;\n  }\n\n  const match = expr.body.match(cssVariableExpression);\n  return match ? match[1] : value;\n}\n\n// The instanceof Node/HTMLElement/SVGElement checks can fail if the target element\n// belongs to a different window than the respective type.\n\nexport function isNode(target: unknown): target is Node {\n  return (\n    target instanceof Node ||\n    (target !== null &&\n      typeof target === 'object' &&\n      'nodeType' in target &&\n      typeof target.nodeType === 'number' &&\n      'nodeName' in target &&\n      typeof target.nodeName === 'string' &&\n      'parentNode' in target &&\n      typeof target.parentNode === 'object')\n  );\n}\n\nexport function isHTMLElement(target: unknown): target is HTMLElement {\n  return (\n    target instanceof HTMLElement ||\n    (isNode(target) &&\n      target.nodeType === Node.ELEMENT_NODE &&\n      'style' in target &&\n      typeof target.style === 'object' &&\n      typeof target.ownerDocument === 'object' &&\n      !isSVGElement(target))\n  );\n}\n\nexport function isSVGElement(target: unknown): target is SVGElement {\n  return (\n    target instanceof SVGElement ||\n    (isNode(target) &&\n      target.nodeType === Node.ELEMENT_NODE &&\n      'ownerSVGElement' in target &&\n      typeof target.ownerSVGElement === 'object')\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}