{"ast":null,"code":"// Audio sample buffer to minimize reallocations\nclass ExpandableBuffer {\n  constructor() {\n    // Start with half a second's worth of buffered audio capacity\n    this.buffer = new Float32Array(12000);\n    this.readIndex = 0;\n    this.writeIndex = 0;\n    this.underflowedSamples = 0;\n    this.isInitialBuffering = true;\n    this.initialBufferLength = 4800; // 200ms at 24kHz - adjust for responsiveness\n    this.lastWriteTime = 0;\n  }\n  write(samples) {\n    const now = Date.now();\n    this.lastWriteTime = now;\n    if (this.writeIndex + samples.length <= this.buffer.length) {\n      // Enough space to append the new samples\n    } else {\n      // Not enough space ...\n      if (samples.length <= this.readIndex) {\n        // ... but we can shift samples to the beginning of the buffer\n        const subarray = this.buffer.subarray(this.readIndex, this.writeIndex);\n        this.buffer.set(subarray);\n      } else {\n        // ... and we need to grow the buffer capacity to make room for more audio\n        const newLength = (samples.length + this.writeIndex - this.readIndex) * 2;\n        const newBuffer = new Float32Array(newLength);\n        newBuffer.set(this.buffer.subarray(this.readIndex, this.writeIndex));\n        this.buffer = newBuffer;\n      }\n      this.writeIndex -= this.readIndex;\n      this.readIndex = 0;\n    }\n    this.buffer.set(samples, this.writeIndex);\n    this.writeIndex += samples.length;\n    if (this.writeIndex - this.readIndex >= this.initialBufferLength) {\n      // Filled the initial buffer length, so we can start playback with some cushion\n      this.isInitialBuffering = false;\n    }\n  }\n  read(destination) {\n    let copyLength = 0;\n    if (!this.isInitialBuffering) {\n      // Only start to play audio after we've built up some initial cushion\n      copyLength = Math.min(destination.length, this.writeIndex - this.readIndex);\n    }\n    destination.set(this.buffer.subarray(this.readIndex, this.readIndex + copyLength));\n    this.readIndex += copyLength;\n    if (copyLength < destination.length) {\n      // Not enough samples (buffer underflow). Fill the rest with silence.\n      destination.fill(0, copyLength);\n      this.underflowedSamples += destination.length - copyLength;\n    }\n    if (copyLength === 0) {\n      // Ran out of audio, so refill the buffer to the initial length before playing more\n      this.isInitialBuffering = true;\n    }\n  }\n  clearBuffer() {\n    this.readIndex = 0;\n    this.writeIndex = 0;\n    this.isInitialBuffering = true;\n  }\n}\nclass AudioPlayerProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.playbackBuffer = new ExpandableBuffer();\n    this.port.onmessage = event => {\n      if (event.data.type === \"audio\") {\n        this.playbackBuffer.write(event.data.audioData);\n      } else if (event.data.type === \"initial-buffer-length\") {\n        // Override the current playback initial buffer length\n        this.playbackBuffer.initialBufferLength = event.data.bufferLength;\n      } else if (event.data.type === \"barge-in\") {\n        this.playbackBuffer.clearBuffer();\n      }\n    };\n  }\n  process(inputs, outputs, parameters) {\n    const output = outputs[0][0]; // Assume one output with one channel\n    this.playbackBuffer.read(output);\n    return true; // True to continue processing\n  }\n}\nregisterProcessor(\"audio-player-processor\", AudioPlayerProcessor);","map":{"version":3,"names":["ExpandableBuffer","constructor","buffer","Float32Array","readIndex","writeIndex","underflowedSamples","isInitialBuffering","initialBufferLength","lastWriteTime","write","samples","now","Date","length","subarray","set","newLength","newBuffer","read","destination","copyLength","Math","min","fill","clearBuffer","AudioPlayerProcessor","AudioWorkletProcessor","playbackBuffer","port","onmessage","event","data","type","audioData","bufferLength","process","inputs","outputs","parameters","output","registerProcessor"],"sources":["/Users/theo/Library/CloudStorage/OneDrive-RackspaceInc/Documents/aws_hackathon/react-client/src/helper/audioPlayerProcessor.worklet.js"],"sourcesContent":["// Audio sample buffer to minimize reallocations\nclass ExpandableBuffer {\n    constructor() {\n        // Start with half a second's worth of buffered audio capacity\n        this.buffer = new Float32Array(12000);\n        this.readIndex = 0;\n        this.writeIndex = 0;\n        this.underflowedSamples = 0;\n        this.isInitialBuffering = true;\n        this.initialBufferLength = 4800;  // 200ms at 24kHz - adjust for responsiveness\n        this.lastWriteTime = 0;\n    }\n\n    write(samples) {\n        const now = Date.now();\n        this.lastWriteTime = now;\n\n        if (this.writeIndex + samples.length <= this.buffer.length) {\n            // Enough space to append the new samples\n        }\n        else {\n            // Not enough space ...\n            if (samples.length <= this.readIndex) {\n                // ... but we can shift samples to the beginning of the buffer\n                const subarray = this.buffer.subarray(this.readIndex, this.writeIndex);\n                this.buffer.set(subarray);\n            }\n            else {\n                // ... and we need to grow the buffer capacity to make room for more audio\n                const newLength = (samples.length + this.writeIndex - this.readIndex) * 2;\n                const newBuffer = new Float32Array(newLength);\n                newBuffer.set(this.buffer.subarray(this.readIndex, this.writeIndex));\n                this.buffer = newBuffer;\n            }\n            this.writeIndex -= this.readIndex;\n            this.readIndex = 0;\n        }\n        this.buffer.set(samples, this.writeIndex);\n        this.writeIndex += samples.length;\n        if (this.writeIndex - this.readIndex >= this.initialBufferLength) {\n            // Filled the initial buffer length, so we can start playback with some cushion\n            this.isInitialBuffering = false;\n        }\n    }\n\n    read(destination) {\n        let copyLength = 0;\n        if (!this.isInitialBuffering) {\n            // Only start to play audio after we've built up some initial cushion\n            copyLength = Math.min(destination.length, this.writeIndex - this.readIndex);\n        }\n        destination.set(this.buffer.subarray(this.readIndex, this.readIndex + copyLength));\n        this.readIndex += copyLength;\n\n        if (copyLength < destination.length) {\n            // Not enough samples (buffer underflow). Fill the rest with silence.\n            destination.fill(0, copyLength);\n            this.underflowedSamples += destination.length - copyLength;\n        }\n        if (copyLength === 0) {\n            // Ran out of audio, so refill the buffer to the initial length before playing more\n            this.isInitialBuffering = true;\n        }\n    }\n\n    clearBuffer() {\n        this.readIndex = 0;\n        this.writeIndex = 0;\n        this.isInitialBuffering = true;\n    }\n}\n\nclass AudioPlayerProcessor extends AudioWorkletProcessor {\n    constructor() {\n        super();\n        this.playbackBuffer = new ExpandableBuffer();\n        this.port.onmessage = (event) => {\n            if (event.data.type === \"audio\") {\n                this.playbackBuffer.write(event.data.audioData);\n            }\n            else if (event.data.type === \"initial-buffer-length\") {\n                // Override the current playback initial buffer length\n                this.playbackBuffer.initialBufferLength = event.data.bufferLength;\n            }\n            else if (event.data.type === \"barge-in\") {\n                this.playbackBuffer.clearBuffer();\n            }\n        };\n    }\n\n    process(inputs, outputs, parameters) {\n        const output = outputs[0][0]; // Assume one output with one channel\n        this.playbackBuffer.read(output);\n        return true; // True to continue processing\n    }\n}\n\nregisterProcessor(\"audio-player-processor\", AudioPlayerProcessor);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}